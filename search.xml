<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Apk安装流程</title>
      <link href="/%E5%AE%89%E5%8D%93-Apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"/>
      <url>/%E5%AE%89%E5%8D%93-Apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Apk安装的四种方式："><a href="#Apk安装的四种方式：" class="headerlink" title="Apk安装的四种方式："></a>Apk安装的四种方式：</h2><ol><li>系统应用安装：没有安装界面，在开机时自动完成。</li><li>网络下载应用安装:  没有安装界面，在应用市场完成。</li><li>ADB命令安装:  没有安装界面，通过命令直接安装。</li><li>外部设备安装:  有安装界面，通过SD卡等外部设备安装，由packageInstaller处理安装逻辑。</li></ol><h2 id="涉及到的目录："><a href="#涉及到的目录：" class="headerlink" title="涉及到的目录："></a>涉及到的目录：</h2><p>1.system&#x2F;app ： 系统自带的应用程序，获得root权限才能删除。<br>2.data&#x2F;app ： 用户程序安装目录，安装时会把apk文件复制到此目录下。<br>3.data&#x2F;data ： 存放应用程序的数据。<br>4.data&#x2F;dalvik-cache ： 将apk中的dex文件安装到该目录下，dex文件即为可执行文件。</p><h2 id="大致安装过程"><a href="#大致安装过程" class="headerlink" title="大致安装过程"></a>大致安装过程</h2><ol><li><h4 id="拷贝apk到指定的目录"><a href="#拷贝apk到指定的目录" class="headerlink" title="拷贝apk到指定的目录"></a>拷贝apk到指定的目录</h4></li></ol><ul><li>用户安装的apk首先会拷贝到&#x2F;data&#x2F;app下</li><li>但系统出厂的apk文件会被放到&#x2F;system分区下</li></ul><ol start="2"><li><h4 id="加载apk、拷贝文件、创建应用的数据目录："><a href="#加载apk、拷贝文件、创建应用的数据目录：" class="headerlink" title="加载apk、拷贝文件、创建应用的数据目录："></a>加载apk、拷贝文件、创建应用的数据目录：</h4><p>为了加快APP的启动速度，apk在安装的时候，会首先将APP的可执行文件（dex）拷贝到&#x2F;data&#x2F;dalvik-cache目录下，缓存起来。再在&#x2F;data&#x2F;data&#x2F;目录下创建应用程序的数据目录，用来存放应用的数据库、xml文件、cache、二进制的so动态库等。</p></li><li><h4 id="解析apk的AndroidManifest-xml文件："><a href="#解析apk的AndroidManifest-xml文件：" class="headerlink" title="解析apk的AndroidManifest.xml文件："></a>解析apk的AndroidManifest.xml文件：</h4><p>在安装apk的过程中，会解析apk的AndroidManifest.xml文件，将apk的权限、应用包名、apk的安装位置、版本、userID等重要信息保存在&#x2F;data&#x2F;system&#x2F;packages.xml文件中。这些操作都是在PackageManagerService中完成的。</p></li><li><h4 id="显示icon图标"><a href="#显示icon图标" class="headerlink" title="显示icon图标"></a>显示icon图标</h4><p>应用程序经过PMS中的逻辑处理后，发送安装成功的广播,<br>Launcher收到广播之后，显示其icon。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPU负载分析下的最佳实践</title>
      <link href="/%E5%AE%89%E5%8D%93-GPU%E8%B4%9F%E8%BD%BD%E5%88%86%E6%9E%90%E4%B8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/%E5%AE%89%E5%8D%93-GPU%E8%B4%9F%E8%BD%BD%E5%88%86%E6%9E%90%E4%B8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<ul><li><p>子控件布局设计中尽量减少不必要的背景设置如父控件布局已有背景，子控件除非UI设计要求，无需单独设置背景色，继承父控件的即可。</p></li><li><p>移除被遮挡的背景如子控件会完全遮挡父控件，父控件子控件同时设置了背景，会导致一次过度绘制。因为父控件在当前布局下是不可见的，所以可以直接移除背景。</p></li><li><p>减少布局嵌套，使视图层次扁平化，降低view重叠数量，降低overdraw可能性</p></li><li><p>Canvas.clipRect减少重叠区域过度绘制</p></li><li><p>使用ClipOutlineProvider绘制圆角减少过度绘制</p></li><li><p>慎用半透明效果</p></li><li><p>应用程序可以通过setContextPriority()设置当前渲染上下文的优先级，优先级高先执行，避免其因抢不到GPU时间片而卡顿。</p></li><li><p>避免使用GPU合成</p><ul><li>通过 SurfaceControl.setCornerRadius 设置窗口圆角</li><li>Surface的PixelFormat使用RGBA_1010102</li><li>通过SurfaceControl. setShadowRadius设置阴影半径</li><li>Cursor鼠标箭头类型的layer</li></ul></li><li><p>瞬时任务较重的场景使用perflock进行CPU&#x2F;GPU boost，如冷启、滑动等</p></li><li><p>多屏场景下，动态调整屏幕合成优先级 如主屏launcher、副驾feed同时动会出现feed流卡顿问题，考虑将用户体验&#x2F;帧率要求比较高的图层合成提前。</p></li><li><p>降低渲染目标的复杂度，如顶点数量，光照、动态阴影、蒙层等效果，最终目的还是避免overdraw，减少GPU的计算复杂度</p></li><li><p>进行必要的纹理压缩，减少内存带宽压力</p></li><li><p>如有可能，尽量减少渲染频率，即帧率</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
            <tag> GPU负载 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生的思考</title>
      <link href="/%E4%B8%80%E7%94%9F/"/>
      <url>/%E4%B8%80%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="普通人的一生"><a href="#普通人的一生" class="headerlink" title="普通人的一生"></a>普通人的一生</h1><ul><li><p>六岁之前：学前教育</p></li><li><p>六岁：一年级</p></li><li><p>十二：小升初</p></li><li><p>十五：中考</p></li><li><p>十八：高考<br>˚</p></li><li><p>二十二：毕业，开始工作</p></li><li><p>二十五：奋斗三年，月薪五千，借钱首付，还贷三十年</p></li><li><p>二十七：借钱凑彩礼，终于结良缘</p></li><li><p>二十八：得子，攒钱准备学前早教</p></li><li><p>三十四：孩子入学，九年义务，一年学杂五千补习一万，雪上加霜</p></li><li><p>四十三：中考升高中，学杂费升级，一年一万，补习一年亦一万</p></li><li><p>四十六：孩子成年，勤工俭学，不问家里要一分，己身力衰心有余</p></li><li><p>五十：孩子毕业，开始工作，己身年衰，高龄下岗，零工碎挣，聊以厘毫</p></li><li><p>五十三：几年攒出一点，与子付了首付，老年小区不光彩，迎娶儿媳要新房</p></li><li><p>五十五：终于熬完三十年，又贷一笔凑彩礼</p></li><li><p>五十六：亲孙落地蹒跚步，半个甲子一轮回</p></li><li><p>六十五：一生劳苦终需报，碎银难补碎玉身</p></li><li><p>七十五：独步尘寰终离世，回首往事幸无疾。芸芸碌碌何所道，一抔清白同山阿。</p></li></ul><p>《孩子，我宁愿欠你一个快乐的少年，也不愿看到你卑微的成年》</p><p>后来有人突然奇想，就接了下去：</p><p>《少年，我宁愿欠你一个后浪的成年，也不愿看到你悲惨的中年》</p><p>《后生，我宁愿欠你一个体面的中年，也不愿看到你凄惨的老年》</p><p>《先生，我宁愿欠你一个安稳的老年，也不愿看到你无助的晚年》</p><p>《逝者，我宁愿欠你一个盛大的葬礼，也不愿看到你下一代输在起跑线上》</p><p>所有的合起来，不就是：</p><p>《孩子，我宁愿你从未来过，也不愿你有个悲惨的一生。》<br><strong>我做了很多角色，唯独没有做过自己</strong></p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/shaoxiongdu/202208071112132.jpeg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-线程安全</title>
      <link href="/JVM-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/JVM-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java线程安全-JVM角度解析"><a href="#Java线程安全-JVM角度解析" class="headerlink" title="Java线程安全-JVM角度解析"></a>Java线程安全-JVM角度解析</h1><blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/JVMStudy">JVM底层原理解析</a></p></blockquote><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>​ 当多个线程同时访问一个对象，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要考虑额外的同步，或者在调用方法时进行一些其他的协作，调用这个对象的行为都可以获得正确的结果。那么就称这个对象是线程安全的。</p><p>​ 这个定义是严谨并且有可操作性的，他要求线程安全的代码都必须具备一个共同的特性。代码本身封装了所有必要的正确性保障手段（如互斥同步等）。令调用者无需关心多线程下的调用问题。更无需自己实现任何措施来保证安全。</p><h2 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h2><p>​ 在Java语言中，从JVM底层来看的话，线程安全并不是一个非黑即白的二元排他选项，按照<code>安全程度</code>来划分，我们可以将Java中各种操作共享的数据分为五类:<code> 不可变</code>、<code>绝对线程安全</code>、<code>相对线程安全</code>、<code>线程兼容</code>、<code>线程对立</code></p><p>​ 接下来，我们一一介绍。</p><ul><li><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>​ 在Java中，不可变的对象一定是安全的。比如用final修饰的变量。只要一个不可见的对象被创建出来，其外部的可见状态就不会改变，永远不会看到它在多个线程中处于不一致的状态。在Java中，不可变带来的线程安全是最直接的，也是最纯粹的。</p><p>​ 基本数据类型： 在定义的时候用final修饰即可。</p><p>​ 引用数据类型：由于目前为止Java中还没有提供对应的支持，需要我们自己封装，将共享数据封装为一个不可变的对象，具体来说，我们可以把对象中的属性封装为final类型。这样在构造方法结束之后，他就是一个不可比变的值。</p><p>​ 比如String，Integer,Number,Long,Double等基本数据类型的包装类，都是将value部分修饰为final。</p><p>​ String的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure><p>Integer的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure><p>Double的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> value;</span><br></pre></td></tr></table></figure></li><li><h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>​ 绝对线程安全能够完全满足线程安全的定义，但是在Java中标注自己是线程安全的类，并不一定是绝对线程安全的类。</p><p>​ 比如Vector类，众所周知，它是一个线程安全类，常用的方法都被<code>synchronized</code><br>修饰。但是，它并不是绝对的线程安全，如果要做到绝对线程安全，必须在内部维护一组一致性的快照访问。每次对元素进行改动都要产生新的快照。但是付出的时间和空间成本是巨大的。</p></li><li><h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>​ 相对线程安全就是我们通常意义上讲的线程安全，他需要保证对这个对象的单次操作是安全的。在Java中，大部分的声明为线程安全的类都是这个级别。比如<br>Vector,HashTable,Collections中的synchronizedCollection()方法包装的集合等。</p></li><li><h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>​ 线程兼容是指对象本身是非线程安全的，但是可以通过在调用端正确的使用同步手段（加锁）来保证在并发下是安全的。Java中大部分的类都在此级别。比如ArrayList,HashMap等。</p></li><li><h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>​ 线程对立是指不管调用端如何进行同步加锁，都无法保证并发下的线程安全。在Java中这种类是很少的，我们要避免使用。比如System.setIn(),System.setOut()等。</p></li></ul><h2 id="线程安全的实现方案"><a href="#线程安全的实现方案" class="headerlink" title="线程安全的实现方案"></a>线程安全的实现方案</h2><p>在Java中，实现线程安全，主要有三种方案, <code>互斥同步</code>、<code>非阻塞同步</code>、<code>无同步方案</code></p><h2 id="互斥同步（悲观锁）"><a href="#互斥同步（悲观锁）" class="headerlink" title="互斥同步（悲观锁）"></a>互斥同步（悲观锁）</h2><h3 id="synchronized的实现"><a href="#synchronized的实现" class="headerlink" title="synchronized的实现"></a><code>synchronized的实现</code></h3><p>​ 此关键字经过javac编译之后，会生成两条字节码指令.<code>monitorenter</code>和<code>monitorexit</code>。</p><p>比如以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SynchronizedTest.class)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​ 反编译之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">2</span>&lt;cn/shaoxiongdu/chapter6/SynchronizedTest&gt;</span><br><span class="line">        <span class="number">2</span> dup</span><br><span class="line">        <span class="number">3</span> astore_1</span><br><span class="line">        <span class="number">4</span> monitorenter</span><br><span class="line">        <span class="number">5</span> aload_1</span><br><span class="line">        <span class="number">6</span> monitorexit</span><br><span class="line">        7goto <span class="number">15</span>(+<span class="number">8</span>)</span><br><span class="line">        <span class="number">10</span> astore_2</span><br><span class="line">        <span class="number">11</span> aload_1</span><br><span class="line">        <span class="number">12</span> monitorexit</span><br><span class="line">        <span class="number">13</span> aload_2</span><br><span class="line">        <span class="number">14</span> athrow</span><br><span class="line">        15return</span><br></pre></td></tr></table></figure><p>​ 可以看到，在偏移址为4的地方，有一条字节码指令<code>monitorenter</code>,表示<code>synchronized</code>开始的地方，也就是表示开启同步的位置，在偏移址为12的地方，有一条<code>monitorexit</code>表示同步结束的地方。</p><p>​ 这两个指令都需要一个引用类型的参数来指明需要锁住的对象。如果代码中指定了，则使用指定的对象锁，如果出现在方法声明位置，那么虚拟机会判断，如果是实例方法则锁实例对象，如果是静态方法则锁类对象。</p><p>​ 在执行<code>monitorenter</code>时，首先虚拟机会尝试获取对象锁</p><ul><li>如果获取到对象锁，或者当前线程已经有了此对象锁<ul><li>则将对象锁中对象头位置的锁计数器+1，</li><li>在执行到<code>monitorexit</code>时，会将其-1。一旦当前锁对象的锁计数器为0，则当前线程就会释放对象的对象锁。</li></ul></li><li>如果获取不到，则当前线程进入阻塞状态。直到对象锁的值变为0。也就是持有对象锁的线程释放该锁。</li></ul><p>特征：</p><ul><li>可重入的，同一条线程进入同步块多次也不会被锁死。</li><li>在同步块中执行的线程会无条件的阻塞其他线程的进入。这意味着无法像处理数据库那样强制让已获取锁的线程释放锁，也无法让正在的等待锁的进程退出。</li></ul><p>从执行的成本来看，<code>synchronized</code><br>是一个重量级的操作。主流的Java虚拟机实现中，Java的线程是映射到操作系统的内核线程中的，如果要唤醒或者阻塞一个线程，需要从用户态切换到内核态。这种转化是很耗时的。所以<code>synchronized</code><br>是一个重量级的操作。在有必要的情况下，再去使用其。</p><h3 id="lock的实现"><a href="#lock的实现" class="headerlink" title=" lock的实现"></a><code> lock的实现</code></h3><p>​ 在JDK1.5之后，Java类库中新提供了java.util.concurrent包，其中的locks.Lock接口便成为Java另外一种互斥同步的手段。</p><p>​ 该接口的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁。如果锁已被其他线程获取，则进行等待。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁，如果获取成功，则返回true 否则返回false 立即返回 不会和lock一样等待</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 使用Lock接口的实现类，用户可以以<code>非块结构</code>来实现互斥同步，从而摆脱了语言的束缚，改为在类库层面去实现同步，这也为日后扩展出不同的调度算法，不同的特性，不同性能的各种锁提供了空间。</p><p>​ 重入锁（ReentrantLock）是Lock接口中最常见的一种实现方式。故名思意，他和<code>synchronized</code>一样是可以重入的。写法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//处理任务</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();  <span class="comment">//释放锁 不在finally处释放可能会发生死锁 </span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了如下的功能。</p><ul><li><p>等待可中断</p><p>​ 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待。对于处理执行时间比较长的同步块很有帮助</p></li><li><p>公平锁</p><p>​ 当多个线程在等待同一个锁的时候，必须按照申请锁的顺序来依次获得锁。<code>syn</code>    是非公平的，<code>reentrantLock</code>默认也是非公平的，需要在构造函数中传入true指定使用公平锁。（使用公平锁会导致性能急剧下降）</p></li><li><p>锁绑定多个条件</p><p>​ 一个<code>ReentrantLock</code>对象可以同时绑定多个Condition对象。只需要多次调用newCondition方法即可。</p></li></ul><blockquote></blockquote><p>这种互斥同步的放方案主要问题是在线程阻塞和唤醒的时候会带来性能开销问题。从解决问题的方式上看，互斥同步（阻塞同步）属于一种悲观的并发策略，认为只要是别的线程过来，就一定会修改数据。无论是否真的会修改，他都会进行加锁（此处讨论的是概念模型，实际虚拟机会优化一些不必要的加锁）。这会导致用户态和内核态频繁切换，并且需要维护锁的计数器。比较繁琐。</p><h2 id="非阻塞同步（乐观锁）"><a href="#非阻塞同步（乐观锁）" class="headerlink" title="非阻塞同步（乐观锁）"></a>非阻塞同步（乐观锁）</h2><p>​    <strong>基于冲突检测的乐观并发策略。</strong></p><p>​ 通俗的说，就是不管风险，先进行操作。如果数据没有被修改，则修改成功。如果数据被修改，则不断重试。直到出现没有竞争的共享数据为止。</p><p>​ 此种方案需要硬件的发展，因为进行<code>检测是否修改</code>和<code>最终写入</code><br>这两个操作必须保证原子性。如果这里用前边的互斥同步来解决，就没有什么意义了，所以需要硬件层面的支持。确保在语义上看起来有多个操作的行为只需要一条处理器指令就可以完成。常见的这种指令有</p><ul><li><p><code>测试并设置 TestAndSet</code></p></li><li><p><code>获取并增加 FetchAndIncrement</code></p></li><li><p><code>交换 Swap</code></p></li><li><p><code>比较和交换: CompareAndSwap</code></p><p>在Java中完成乐观锁用的是<code>比较和交换</code>CAS指令。</p><p>CAS指令需要有三个操作数，一个是旧的预期值A，一个是内存位置V，还有一个新值B。</p><p>​ 当旧的预期值与内存中真正的值相同的时候，就将旧值替换为新值。否则就不更新。</p><p>在JDK1.5之后，Java类库中才开始使用CAS操作，该操作由 <code>sun.misc.Unsafe</code>类中的方法包装提供。虚拟机会对这些方法进行特殊处理，保证编译之后是一条平台相关的处理器CAS指令。</p><p>比如<code>AtomicInteger</code>就是包装了CAS指令之后的线程安全类，他的方法都设置在一个死循环中，不断尝试将一个新值赋给内存位置的值，如果失败，说明被其他线程改了，于是再次循环进行下一次操作，直到修改成功位置。</p><p>尽管CAS看起来很美好，但是它存在一个逻辑漏洞，当别的线程将值从A改为B，然后又改回A的时候，当前线程是不会发现的。这个漏洞叫做CAS的<code>ABA问题</code><br>，JUC为了解决这个问题，提供了一个带有标记的原子引用类<code>AtomicStampedReference</code>。它通过控制变量值的版本来解决。</p></li></ul><blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/JVMStudy">JVM底层原理解析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-锁优化</title>
      <link href="/JVM-%E9%94%81%E4%BC%98%E5%8C%96/"/>
      <url>/JVM-%E9%94%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/JVMStudy">JVM底层原理解析</a></p></blockquote><p>​<br>高效并发是JDK5升级到JDK6后一项重要的改进，HotSpot虚拟机开发团队在这个版本上花费了巨大的资源去实现各种锁优化。比如，自旋锁，自适应自旋锁，锁消除，锁膨胀，轻量级锁，偏向锁等。这些技术都是为了在线程之间更高效的共享数据及解决竞争问题。从而提高程序的运行效率。</p><h2 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h2><ol><li><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3></li></ol><p>​ 在互斥同步的时候，对性能影响最大的就是阻塞的实现，挂起线程，恢复线程等的操作都需要用户态转为内核态去完成。这些操作给性能带来了巨大的压力。</p><p>​<br>虚拟机的开发团队也注意到，共享数据的锁定状态只会持续很短的时间。为了这很短的时间让线程挂起，然后转为内核态的时间可能比锁定状态的时间更长。所以，我们可以让等待同步锁的进程不要进入阻塞，而是在原地稍微等待一会儿，不要放弃处理器的执行时间，看看持有锁的线程是不是很快就会释放锁。为了让线程等待，我们可以让线程执行一个<code>忙循环（原地自旋）</code><br>,这就是自旋锁。</p><p>​ 自旋锁在JDK1.4.2之后就已经引入，但是默认是关闭的。我们可以使用<code>-XX:+UseSpinning</code><br>参数来开启。在JDK1.6之后就默认开启了。自旋锁并不是阻塞，所以它避免了用户态到内核态的频繁转化，但是它是要占用处理器的执行时间的。</p><p>​ 如果占有对象锁的线程在很短的时间内就执行完，然后释放锁，这样的话，自旋锁的效果就会非常好。</p><p>​ 如果占有对象锁的线程执行时间很长，那么自旋锁会白白消耗处理器的执行时间，这就带来了性能的浪费。这样的话，还不如将等待的线程进行阻塞。默认的自旋次数是10，也就是说，如果一个线程自旋10次之后，还没有拿到对象锁，那么就会进行阻塞。</p><p>​ 我们也可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p><ol start="2"><li><h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>​ 无论是使用默认的10次，还是用户自定义的次数，对整个虚拟机来说所有的线程都是一样的。但是同一个虚拟机中线程的状态并不是一样的，有的锁对象长一点，有的短一点，所以，在JDK1.6的时候，引入了<code>自适应自旋锁</code>。</p><p>​ 自适应自旋锁意味着自旋的时间不在固定了，而是根据当前的情况动态设置。</p><p>​ 主要取决于<code>同一个锁上一次的自旋时间</code>和<code>锁的拥有者的状态</code>。</p><p>​ 如果在同一个对象锁上，上一个获取这个对象锁的线程在自旋等待成功了，没有进入阻塞状态，说明这个对象锁的线程执行时间会很短，虚拟机认为这次也有可能再次成功，进而允许此次自旋时间可以更长一点。</p><p>​ 如果对于某个锁，自旋状态下很少获得过锁，说明这个对象锁的线程执行时间相对会长一点，那么以后虚拟机可能会直接省略掉自旋的过程。避免浪费处理器资源。</p><p>​ 自适应自旋锁的加入，随着程序运行时间的增长以及性能监控系统信息的不断完善，虚拟机对程序的自旋时间预测越来越准确，也就是<code>虚拟机越来越聪明了</code>。</p></li></ol><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>​ 锁消除指的是，在即时编译器运行的时候，代码中要求某一段代码块进行互斥同步，但是虚拟机检测到不需要进行互斥同步，因为没有共享数据，此时，虚拟机会进行优化，将互斥同步消除。</p><p>​ 锁消除的主要判定依据来源于<code>逃逸分析</code>的数据支持。具体来说，如果虚拟机判断到，在一段代码中，创建的对象不会逃逸出去到其他线程，那么就可以把他当作栈上数据对待，同步也就没有必要了。</p><p>​ 但是，大家肯定有疑问，变量是否逃逸，写代码的程序员应该比虚拟机清楚，该不该加同步互斥程序员很自信。还要让虚拟机通过复杂的过程间分析吗，这个问题的答案是：</p><p>​ 有许多互斥同步的要求并不是程序员自己加入的，互斥同步的代码在Java中出现的程度很频繁。</p><p>​ 我们来举一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String s1,String s2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1+s2;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​ 上边的代码很简单，将两个字符串连接，然后返回，不涉及到任何互斥同步的要求。</p><p>​ 但是，我们来编译它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0new #<span class="number">2</span>&lt;java/lang/StringBuilder&gt;</span><br><span class="line">       <span class="number">3</span> dup</span><br><span class="line">       <span class="number">4</span> invokespecial #<span class="number">3</span>&lt;java/lang/StringBuilder.&lt;init&gt; :()V&gt;</span><br><span class="line">       <span class="number">7</span> aload_1</span><br><span class="line">       <span class="number">8</span> invokevirtual #<span class="number">4</span>&lt;java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;</span><br><span class="line">       <span class="number">11</span> aload_2</span><br><span class="line">       <span class="number">12</span> invokevirtual #<span class="number">4</span>&lt;java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;</span><br><span class="line">       <span class="number">15</span> invokevirtual #<span class="number">5</span>&lt;java/lang/StringBuilder.toString:()Ljava/lang/String;&gt;</span><br><span class="line">       <span class="number">18</span> areturn</span><br></pre></td></tr></table></figure><p>​<br>会发现，字节码中出现了StringBuilder的拼接操作。因为字符串是不可变的，在编译阶段会对String的连接自动优化。也就是用StringBuilder来连接。我们都知道，这个类是线程安全的，也就是说StringBuilder的拼接操作是需要互斥同步的条件的。此时，代码流程可能是以下这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String s1,String s2)</span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​ 此时，代码会有互斥同步，锁住sb这个对象。这样的话，就会出现程序员没有加入互斥同步条件，但字节码中以及有了。</p><p>​ 这个时候，<code>锁消除</code>就发挥作用了，通过虚拟机的逃逸分析，发现sb这个对象不会逃逸出去，别的线程绝对不会访问到它，sb的动态作用域就在此方法中，此时，锁消除就会将这里的互斥同步进行消除。</p><p>​ 运行的时候，就会忽略到同步措施直接执行。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>​ 原则上，我们编写代码的时候，总是推荐将同步代码块的作用范围尽可能的缩小，只有共享数据的地方同步即可。这样是为了使得同步的操作变少，等待锁的线程能尽快的拿到锁。</p><p>​ 但是，如果一段代码中自始至终都锁的是同一个对象，那么就会对这个对象进行重复的加锁，释放，加锁，释放。频繁的进行用户态和内核态的切换，效率居然变低了。</p><p>​<br>上边的代码就是这种情况，每一次的append操作都对sb进行加锁释放，加锁释放，如果虚拟机探测到有一串零碎的操作对一个对象重复的加锁，释放，此时，虚拟机就会把加锁同步的范围粗化到整个操作的最外层。以上边的代码为例，虚拟机扩展到第一个append到最后一个append。这样的话，只需要加锁释放一次即可。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>​<br>轻量级锁是JDK1.6之后加入的新型锁机制，轻量级是相对应于操作系统互斥量来实现的传统锁而言的。因此，传统锁就被称之为重量级锁。但是，要注意，轻量级并不是用来代替重量级的，它设计的初衷是在<code>没有多线程竞争的前提下，减少传统的重量级锁带来的性能消耗问题的。</code></p><p>​ 首先，要理解轻量级锁以及后边的偏向锁，必须要先知道，HotSpot中对象的内存布局。对象的内存布局分为三部分，一部分是<code>对象头（Mark Word）</code>，一部分是<code>实例数据</code>，还有一部分<code>对其填充</code>，为了让对象的大小为8字节的整数倍。</p><p>​ 对象头中包括两部分的数据包括，对象的哈希码，GC分代年龄，锁状态等。 如果对象是数组，那么还会有额外的一部分存储数组长度。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051425270.png" alt="image-20210803124244641"></p><p>​ 这些内容在第二章运行时数据区中的<a href="../02-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/08-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D+%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.md">对象的实例化内存布局与访问定位+直接内存</a> 我们已经说过了。不再赘述，此处我们只针对锁的角度进一步细化。</p><p>​ 由于对象头中存储的信息是与对象自身定义数据无关的额外存储成本，所以为了节约效率，他被设计为一个动态的数据结构。会<code>根据对象的状态复用自己的存储空间</code>。具体来说，会根据当前锁状态给每一部分的值赋予不同的意义。</p><p>​ 在32位操作系统下的HotSpot虚拟机中对象头占用32个字节，64位占用64个字节。</p><p>​ 我们以32位操作系统来演示。以下是不同锁状态的情况下，各个部分数据的含义。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051425986.png" alt="image-20210803125123314"></p><p>​ 接下来我们就可以介绍轻量级锁的工作过程了。</p><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><ul><li><p>在代码即将进入同步块的时候，虚拟机就会在当前栈帧中建立一个名为锁记录（Lock Record）的空间。然后将堆中对象的对象头拷贝到<code>锁记录</code><br>（官方给它加了Displaced前缀）便于修改对象头的引用时存储之前的信息。此时线程栈和对象头的情况如下：</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051425067.png" alt="image-20210803131051151"></p></li><li><p>然后，虚拟机将使用<code>CAS（原子）</code>操作尝试把堆中对象的对象头中前30个字节更新为指向<code>锁记录</code>的引用。</p><ul><li><p>如果成功，代表当前线程已经拥有了该对象的对象锁。然后将堆中对象头的锁标志位改为<code>00</code>。此时，代表对象就处于<code>轻量级锁定</code>状态。状态如下所示</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051425809.png" alt="image-20210803132026322"></p></li><li><p>如果失败，也就是堆中对象头的锁状态已经是0，则意味着对象的对象锁别拿走了。</p><ul><li>虚拟机会判断对象的前30个字节是不是指向当前线程<ul><li>如果是，说明当前线程已经拿到了对象锁，可以直<code>接执行同步代码块</code>。</li><li>如果不是，说明对象锁被其他线程拿走了，必须等待。也就是进入<code>自旋模式</code>，如果在自旋一定次数后仍为获得锁，那么轻量级锁将会膨胀成重量级锁。</li></ul></li><li>如果发现有两条以上线程争用同一个对象锁，那么轻量级锁就不在有效，必须<code>膨胀为重量锁</code>，将对象的锁状态改为10。此时，堆中对象的对象头前30个字节的引用就是指向重量级锁。</li></ul></li></ul></li></ul><h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>​ 如果堆中对象头的前30个字节指向当前线程，说明当前线程拥有对象锁，就用CAS操作将加锁的时候复制到栈帧锁记录中的对象头替换到堆中对象的对象头。并将堆中对象头的锁状态改为01。</p><ul><li>如果替换成功，说明<code>解锁完成</code>。</li><li>如果发现有别的线程尝试过获取堆中对象的对象锁，就要在释放锁的同时，唤醒被阻塞的线程。</li></ul><h3 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h3><p>​ 轻量级锁提升性能的依据是：绝大多数的锁在整个同步过程中都是不存在竞争的。这样的话，就通过CAS操作避免了使用操作系统中互斥量的开销。</p><p>​ 如果确实存在多个线程的锁竞争，除了互斥量本身的开销之外，还额外发生了CAS操作的开销。因此，在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>​ 偏向锁也是JDK1.6之后引入的特性，他的目的是<code>消除数据在无竞争状态下的同步原语</code>，进一步提高程序的运行速度。</p><p>​ 轻量级锁是在无竞争的情况下利用CAS原子操作来消除操作系统的互斥量，偏向锁就是在无竞争的情况下把整个同步都消除。</p><p>​ 偏向锁的<code>偏</code>就是偏心的偏，他的意思是 这个锁会偏向于第一个获得它的线程。如果在接下来的执行过程中，该锁一直没有被其他线程获取，那么持有偏向锁的线程就不需要在同步，直接执行。</p><p>​<br>假设当前虚拟机开启了偏向锁（1.6之后默认开启），当锁对象第一次被线程获取的时候，虚拟机会将对象头中最后2字节的锁标志位的值不做设置，依旧是01，将倒数第三个字节偏向模式设置为01。也就是开启偏向模式。同时使用CAS原子操作将获取到这个对象锁的线程记录在对象头中。如果操作成功，那么以后持有偏向锁的线程每次进入同步代码块时，虚拟机都不会在进行同步操作。</p><p>​ 一旦出现别的线程去获取这个锁的情况，偏向模式立马结束。根据锁对象目前是否被锁定来决定是否撤销偏向，撤销后锁标志位恢复到未锁定状态（01）或轻量级锁定（00）。后续的操作就按照轻量级锁去执行。</p><p>​ 偏向锁，轻量级锁的状态转化如下:</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051425896.png" alt="image-20210803141119759"></p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>​ 之前的轻量级锁加锁的时候，会将对象的hash码，分代年龄等数据拷贝出来，便于使用。但是，我们发现，偏向锁的过程中并未拷贝，此时，如果要使用原来对象头的数据，怎么办？</p><p>​ 虚拟机的实现也考虑到了这个问题。</p><p>​ 对象的哈希码并不是创建对象的时候计算的，而是第一次使用的时候，计算的。比如下边String的hash方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 演示hash的计算时间</span></span><br><span class="line"><span class="comment"> 作者：写Bug的小杜 【email@shaoxiongdu.cn】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="comment">//如果之前没有算过，则调用的时候才进行计算。否则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​ 如果一个对象计算过哈希码，那么不管调用多少次，它的哈希值都应该是一样的。</p><p>​ 当一个对象计算过hash码的时候，说明这个对象的哈希码要被用，那么，这个对象就无法进入偏向锁状态。</p><p>​ 如果虚拟机收到一个正在偏向锁的对象的哈希码计算请求，就会立即停止偏向锁模式，膨胀为重量级锁。就会在重量级锁的栈帧中拷贝的锁状态位置中存储对象的运行时数据结构。</p><h3 id="后言-1"><a href="#后言-1" class="headerlink" title="后言"></a>后言</h3><p>​ 偏向锁可以提高带有同步但是无竞争的程序性能，但是它同样是一个带有权衡效益的优化。如果程序中大多数的锁总是被不同的线程访问，那么偏向模式就是多余的。具体问题分析之后，我们可以使用参数<code>-XX:-UseBiasedLocking</code><br>来禁止使用偏向锁优化从而提高程序的运行速度。需要<code>    具体问题，具体分析</code>。</p><blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/JVMStudy">JVM底层原理解析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-Java线程</title>
      <link href="/JVM-Java%E7%BA%BF%E7%A8%8B/"/>
      <url>/JVM-Java%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Java中的JVM是如何实现多线程的？</p><h3 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h3><blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/java-notes">Java超神之路</a></p></blockquote><p>​ 并发不一定都要用到线程，比如PHP中用到的是多进程。但是在Java中并发基本上都是使用线程来实现的。我们先来看看线程在Java虚拟机中是如何实现的。</p><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>​ 主流的操作系统都提供了线程的实现，Java线程则提供了在不同硬件和操作系统下对线程的统一处理。每个已经start且并未结束的Thread类的实例对象都是一个线程。</p><p>​ 我们查看Thread的JDK源码，发现所有的方法都被<code>native</code>修饰。也就是说，Thread是使用平台相关的手段来实现的。在不同的操作系统或者硬件平台都有不同的实现。因此，标题为<code>线程的实现</code>，而不是<code>Java线程的实现</code></p><p>​ 实现线程主要有三种方式</p><ul><li>内核线程 （1:1线程模型）</li><li>用户线程 （1:N 线程模型）</li><li>用户线程 + 轻量级进程 混合 （N:M 线程模型）</li></ul><ol><li><h3 id="内核线程的实现"><a href="#内核线程的实现" class="headerlink" title="内核线程的实现"></a>内核线程的实现</h3><p>​ 内核线程(Kernel-Level Thread，KLT)是由操作系统内核直接支持的线程 。这种线程由内核来完成线程切换。内核通过操纵调度器对内核线程进行控制，并负责将线程的任务映射到各个处理器。</p><p>​ 程序一般不会直接使用内核线程，而是使用它的高级接口：<code>轻量级进程</code>（LWP）。轻量级进程就是我们通常意义上讲的线程。每个轻量级进程都由一个内核线程支持。因此这种方式称为1:1的线程模型</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051425287.png" alt="image-20210801142929121"></p><p>​ 由于内核线程的支持，每个轻量级进程都是一个独立的调度单元。由于是基于系统内核实现的，所以此种方式在对线程进行创建，同步等操作的时候都需要系统内核调用。需要在用户态和系统内核态之间频繁切换，影响性能。</p></li><li><h3 id="用户线程的实现"><a href="#用户线程的实现" class="headerlink" title="用户线程的实现"></a>用户线程的实现</h3><p>​ 用户线程指完全建立在用户态的线程库中，用户线程的创建，同步，销毁，调度等操作完全在用户态中完成，不需要在频繁切换内核态。因此速度很快。很多高性能的数据库中的多线程就是用的用户线程。</p><p>​ 由于是一个进程对应多个用户线程，因此，线程模型是1:N的</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051425555.png" alt="image-20210801143143220"></p><p>缺点：</p><ul><li>由于所有的线程操作都需要由用户处理，所以线程的创建，销毁，切换，调度都是用户需要考虑的问题。</li><li>由于操作系统只将处理器的资源分配到进程程度，所以<code>阻塞如何处理</code>,<code>多处理器如今分配资源</code>等问题都需要由用户解决。</li></ul><p>Java，Ruby等语言都使用过用户线程，但是最终都放弃了。</p></li><li><h3 id="用户线程-轻量级进程-混合实现"><a href="#用户线程-轻量级进程-混合实现" class="headerlink" title="用户线程 + 轻量级进程 混合实现"></a>用户线程 + 轻量级进程 混合实现</h3><p>​ 在这种情况下，既存在用户线程，又存在轻量级进程，<code>用户线程的建立还是在用户态中</code>，因此不需要频繁切换内核态，保证了速度的高效。<code>轻量级进程为用户线程和内核线程的桥梁</code><br>。这样可以使用内核提供的线程调度功能处理用户线程中存在的问题。用户线程和轻量级进程的比例是不确定的。因此是N:M的线程模型</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051425680.png" alt="image-20210801142757700"></p></li></ol><h2 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h2><p>​ Java规范中并没有具体要求使用哪种方式来实现</p><p>​ 在JDK1.2之前，使用一种<code>绿色线程</code>的用户线程来实现的。</p><p>​ JDK1.3之后，普遍采用内核线程来实现，也就是1:1的线程模型。</p><p>​ 以市场占有率最大的HotSpot虚拟机来举例，它的每一个线程都是直接映射到操作系统的原生线程来实现的。中间没有额外的结构，所有的线程调度都是由操作系统完成的，虚拟机全权交给操作系统处理。</p><p>​<br>操作系统支持什么样的线程模型，很大程度上会影响在此系统上的虚拟机的选择。所以在JVM规范中，不会限定使用哪种线程模型。由于Thread类对底层的规范统一，对于上层的Java应用来说，底层的差异都是透明的。只要面向Thread类进行编程就好了。</p><p>​ 这也间接的符合了设计原则中的<code>依赖倒置原则</code>。</p><blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/java-notes">Java超神之路</a> 更多Java相关知识，欢迎访问！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-分析GC日志</title>
      <link href="/JVM-%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97/"/>
      <url>/JVM-%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="分析GC日志"><a href="#分析GC日志" class="headerlink" title="# 分析GC日志"></a># 分析GC日志</h1><h2 id="GC日志的分类"><a href="#GC日志的分类" class="headerlink" title="GC日志的分类"></a>GC日志的分类</h2><ol><li><h3 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051424156.png" alt="image-20210711213910008"></p></li><li><h3 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051424196.png" alt="image-20210711213940661"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-Java内存模型</title>
      <link href="/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/JVM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/JVMStudy">JVM底层原理解析</a></p></blockquote><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>​ JVM虚拟机规范中曾经试图定义一种Java内存模型，来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都可以达到一致性的内存访问效果。</p><p>​<br>然而定义这样一套内存模型并非很容易，这个模型必须足够严谨，才能让Java的并发内存访问操作不会有歧义。但是也必须足够宽松，这样使得虚拟机的具体实现能够有自由的发挥空间来利用各种硬件的优势。经过长时间的验证和弥补，到了JDK1.5（实现了JSR133规范）之后，Java内存模型才终于成熟起来了。</p><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>​ Java内存模型规定了所有的变量都存储在<code>主内存</code>(Main Memory)中，每条线程都有自己的<code>工作内存</code>（Work Memory）</p><ul><li>工作内存中保存了被该线程使用的变量的主内存副本，</li><li>线程对变量的读写操作必须在工作内存中进行。</li><li>而不能直接访问主内存的数据。</li><li>不同的线程也不能互相读写对方的工作内存，线程之间的变量传递必须通过主内存传递。</li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051424145.png" alt="image-20210731210337786"></p><h2 id="主内存和工作内存的交互"><a href="#主内存和工作内存的交互" class="headerlink" title="主内存和工作内存的交互"></a>主内存和工作内存的交互</h2><h3 id="Java内存模型定义了如下八种操作-每一种操作都是原子的，不可再分的"><a href="#Java内存模型定义了如下八种操作-每一种操作都是原子的，不可再分的" class="headerlink" title="Java内存模型定义了如下八种操作(每一种操作都是原子的，不可再分的)"></a>Java内存模型定义了如下八种操作(每一种操作都是<code>原子的</code>，<code>不可再分</code>的)</h3><ul><li><code>lock 锁定</code>： 作用于主内存，将一个变量标识为线程独占状态</li><li><code>unlock: 解锁</code> ： 作用于主内存，将一个线程独占状态的变量释放</li><li><code>read 读取</code> ： 从主内存读取数据到工作内存，便于之后的load操作</li><li><code>load 载入</code>： 把read读取操作从主内存中得到的变量放入工作内存的变量副本中</li><li><code>use 使用</code>： 将工作内存中的变量传递给执行引擎 当虚拟机遇到一个需要使用变量值的字节码时，执行此操作</li><li><code>assign赋值</code>： 将执行引擎中的值赋给工作内存的变量。 当虚拟机遇到一个赋值操作时，执行此操作</li><li><code>store存储</code>： 将工作内存的值传递到主内存 ，便于之后的write操作</li><li><code>write写入</code>：将store存储操作中从工作内存中获取的变量写入到主内存中</li></ul><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><ul><li>如果要把一个变量从主内存拷贝到工作内存，则依次执行read读取操作, load载入操作</li><li>如果要把一个变量从工作内存写入到主内存，则依次执行store存储操作，write写入操作</li></ul><h3 id="上述的8种操作必须满足以下规则："><a href="#上述的8种操作必须满足以下规则：" class="headerlink" title="上述的8种操作必须满足以下规则："></a>上述的8种操作必须满足以下规则：</h3><ul><li>不允许read和load、store和write操作之一单独出现。也就是说不允许一个变量从主内存读取但是工作内存不接受，也不允许工作内存发起回写请求但是主内存不接受。</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><h2 id="volatile特殊规则"><a href="#volatile特殊规则" class="headerlink" title="volatile特殊规则"></a>volatile特殊规则</h2><p>​ volatile可以说是Java虚拟机提供的最轻量级的同步机制。但是它并不容易被正确，完整的理解。</p><p>​ Java内存模型中规定</p><p>​ 当一个变量被定义为<code>volatile</code>之后，表示着线程工作内存无效，对此值的读写操作都会直接作用在主内存上，</p><p>因此它具备对所有线程的<code>立即可见性</code>。以及禁止执行引擎对其进行<code>指令重排序</code></p><ol><li><h3 id="保证此变量对所有线程的立即可见性"><a href="#保证此变量对所有线程的立即可见性" class="headerlink" title="保证此变量对所有线程的立即可见性"></a>保证此变量对所有线程的<code>立即可见性</code></h3><p>​<br>当变量的值被修改之后，新值对于其他线程是立即可知的。普通变量并不能做到这一点，因为普通变量的值在线程之间的传递是要进过主内存来完成的。比如当线程A对变量进行了回写操作，线程B只有在A回写完成之后，在对主内存操作，新值才对B是可见的。在A回写到主内存的过程中，B读取的依旧是旧值。</p><p>​ 但是这并不可以推导出<code>基于volatile变量的运算在并发下是安全的</code>，因为在Java中的运算操作符并不是<code>原子性</code>的。这导致了<code>volatile变量在并发下运算是不安全</code>的。</p><p>通过代码验证<code>volatile变量在并发下运算是不安全</code></p><p>首先我们创建20个线程，每个线程对volatile变量进行1000次的自增操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @作者: 写Bug的小杜 【email@shaoxiongdu.cn】</span></span><br><span class="line"><span class="comment"> * @时间: 2021/07/31</span></span><br><span class="line"><span class="comment"> * @描述: 通过代码验证 【volatile变量在并发下运算是不安全】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//volatile修饰的count</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//count自增方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对count进行递增1000次操作的可运行接口</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始对count进行递增操作&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    increment();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程对count递增操作结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建20个线程并启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">            thread.setName((i+<span class="number">1</span>) + <span class="string">&quot;号线程&quot;</span>);</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//主线程回到就绪状态</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程结束,count = &quot;</span> + count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此程序在并发下是安全的，那么count的值最后肯定是20*1000 &#x3D; 20000；也就是说，如果运行结果为20000，那么<code>volatile变量在并发下运算是安全的</code></p><p>通过多次运行程序，我们发现，count的值永远比20000小。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051424817.png" alt="image-20210731215601479"></p><p>那么，这是为什么呢？</p><p>我们将上方的代码进行反编译，然后分析increment方法的字节码指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> getstatic #<span class="number">2</span> &lt;cn/shaoxiongdu/chapter6/VolatileTest.count : I&gt;</span><br><span class="line"><span class="number">3</span> iconst_1</span><br><span class="line"><span class="number">4</span> iadd</span><br><span class="line"><span class="number">5</span> putstatic #<span class="number">2</span> &lt;cn/shaoxiongdu/chapter6/VolatileTest.count : I&gt;</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我们可以发现，一行count++代码被分为 4行字节码文件去执行。通过对字节码的分析，我们发现，</p><p>当偏移量为0的字节码getStatic将count的值从局部变量表取到操作数栈顶的时候，<code>volatile</code>保证了此时count的值是正确的，但是在执行iconst_1,<br>iadd这些操作的时候，其他线程已经把count的值改变了，此时，操作数栈顶的count为过期的数据，所以putStatic字节码指令就有可能将较小的值同步到主内存中。因此最终的值会比20000稍微小。</p><p>也就是说，<code>volatile变量在并发下运算是不安全的</code> 。</p><p>在并发环境下，volatile的变量只是对全部线程即时可见的，如果要进行写的操作，还是要通过加锁来解决。</p></li></ol><h2 id="针对long和double类型变量的特殊规则"><a href="#针对long和double类型变量的特殊规则" class="headerlink" title="针对long和double类型变量的特殊规则"></a>针对long和double类型变量的特殊规则</h2><p>​ Java内存模型要求对上述的八种操作必须是原子性的，但是对于64位的数据类型（8字节的Long和double）在模型中特别定义了一条宽松的规定： 允许虚拟机将没有被volatile修饰的64位数据的读写划分为2次32位的操作来进行。</p><p>​ 即允许虚拟机实现自行选择是否保证64位的数据类型的load,store,read 和wirte四个操作的原子性。这就是所谓的<code>long和double的非原子性协定</code></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>​ 由Java内存模型直接保证原子性变量操作包括: read,load,assign,use,store和write 6个。我们大致可以认为，基本数据类型的访问，读写操作都是原子性的。</p><p>​ 如果场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足，尽管虚拟机未把lock和unlock的操作直接开放给用户。但是提供了更高层次的字节码指令 <code>monitorenter</code><br>和<code>monitorexit</code>来隐式的使用这两个操作。这两个字节码指令反映到代码层面就是<code>synchronized</code>关键字。这就是为什么<code>synchronized</code>关键字内部的操作也是原子性的。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>​ 可加性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改，对修改是可见的。</p><p>​ Java内存模型中是以这种方式实现的: 在变量修改之后将修改的值同步回主内存，其他线程读取前将新值从主内存同步到工作内存。</p><p>​ 无论是普通变量还是<code>volatile</code>变量都是如此。只不过<code>volatile</code>保证了修改了新值能立即同步到主内存，每次读取都会从主内存同步。</p><p>除了<code>volatile</code>之外，Java中还有两个关键字是可以保证可见性的。<code>synchronized</code>和<code>final</code></p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>​ 同步代码块可实现可见性是因为: 规定对一个变量执行unlock操作之前，必须把变量的值同步至主内存。也就是对一个变量进行解锁的时候，保证主内存中的值已经是最新的值。此时，解锁之后，别的线程从主内存进行同步，值就是正确的。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>​ 表示当final修饰的变量在构造器中一旦初始化完成，此时，不需要将<code>this</code>引用传递出去，别的线程就可以立即感知到final修饰的变量的值。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><blockquote><p>在Java中，如果在本线程内观察，所有的操作都是有序的。</p><p>如果在一个线程中观察另一个线程，则所有的操作都是无序的。</p></blockquote><p>​ 后半句主要是因为： <code>指令重排序</code>和<code>工作内存和主内存同步延迟</code>。</p><blockquote><p>文章已同步至GitHub开源项目: <a href="https://github.com/shaoxiongdu/JVMStudy">JVM底层原理解析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-运行时参数</title>
      <link href="/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0/"/>
      <url>/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM运行时参数"><a href="#JVM运行时参数" class="headerlink" title="JVM运行时参数"></a>JVM运行时参数</h1><h2 id="1-JVM参数选项类型"><a href="#1-JVM参数选项类型" class="headerlink" title="1. JVM参数选项类型"></a>1. JVM参数选项类型</h2><ul><li><h3 id="标准参数选项"><a href="#标准参数选项" class="headerlink" title="标准参数选项"></a>标准参数选项</h3><ul><li><p>比较稳定 以 - 开头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-d32          使用 <span class="number">32</span> 位数据模型 (如果可用)</span><br><span class="line">-d64          使用 <span class="number">64</span> 位数据模型 (如果可用)</span><br><span class="line">-server       选择 <span class="string">&quot;server&quot;</span> VM</span><br><span class="line">              默认 VM 是 server.</span><br><span class="line">    </span><br><span class="line">-cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">-classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">              用 ; 分隔的目录, JAR 档案</span><br><span class="line">              和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">-D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">              设置系统属性</span><br><span class="line">-verbose:[class|gc|jni]</span><br><span class="line">              启用详细输出</span><br><span class="line">-version      输出产品版本并退出</span><br><span class="line">-version:&lt;值&gt;</span><br><span class="line">              警告: 此功能已过时, 将在</span><br><span class="line">              未来发行版中删除。</span><br><span class="line">              需要指定的版本才能运行</span><br><span class="line">-showversion  输出产品版本并继续</span><br><span class="line">-jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">              警告: 此功能已过时, 将在</span><br><span class="line">              未来发行版中删除。</span><br><span class="line">              在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">-? -help      输出此帮助消息</span><br><span class="line">-X            输出非标准选项的帮助</span><br><span class="line">-ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">-enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">              按指定的粒度启用断言</span><br><span class="line">-da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">-disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">              禁用具有指定粒度的断言</span><br><span class="line">-esa | -enablesystemassertions</span><br><span class="line">              启用系统断言</span><br><span class="line">-dsa | -disablesystemassertions</span><br><span class="line">              禁用系统断言</span><br><span class="line">-agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">              加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">              另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">-agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">              按完整路径名加载本机代理库</span><br><span class="line">-javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">              加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">-splash:&lt;imagepath&gt;</span><br><span class="line">              使用指定的图像显示启动屏幕</span><br></pre></td></tr></table></figure><p>有关详细信息, 请参阅 <a href="http://www.oracle.com/technetwork/java/javase/documentation/index.html%E3%80%82">http://www.oracle.com/technetwork/java/javase/documentation/index.html。</a></p></li></ul></li><li><h3 id="X参数选项"><a href="#X参数选项" class="headerlink" title="-X参数选项"></a>-X参数选项</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-Xmixed           混合模式执行（默认）</span><br><span class="line">-Xint             仅解释模式执行</span><br><span class="line">-Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                  设置引导类和资源的搜索路径</span><br><span class="line">-Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                  附加在引导类路径末尾</span><br><span class="line">-Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                  置于引导类路径之前</span><br><span class="line">-Xdiag            显示附加诊断消息</span><br><span class="line">-Xnoclassgc        禁用类垃圾收集</span><br><span class="line">-Xincgc           启用增量垃圾收集</span><br><span class="line">-Xloggc:&lt;file&gt;    将 GC 状态记录在文件中（带时间戳）</span><br><span class="line">-Xbatch           禁用后台编译</span><br><span class="line">-Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">-Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">-Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">-Xprof            输出 cpu 分析数据</span><br><span class="line">-Xfuture          启用最严格的检查，预计会成为将来的默认值</span><br><span class="line">-Xrs              减少 Java/VM 对操作系统信号的使用（请参阅文档）</span><br><span class="line">-Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">-Xshare:off       不尝试使用共享类数据</span><br><span class="line">-Xshare:auto      在可能的情况下使用共享类数据（默认）</span><br><span class="line">-Xshare:on        要求使用共享类数据，否则将失败。</span><br><span class="line">-XshowSettings    显示所有设置并继续</span><br><span class="line">-XshowSettings:system</span><br><span class="line">                  （仅限 Linux）显示系统或容器</span><br><span class="line">                  配置并继续</span><br><span class="line">-XshowSettings:all</span><br><span class="line">                  显示所有设置并继续</span><br><span class="line">-XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">-XshowSettings:properties</span><br><span class="line">                  显示所有属性设置并继续</span><br><span class="line">-XshowSettings:locale</span><br><span class="line">                  显示所有与区域设置相关的设置并继续</span><br></pre></td></tr></table></figure><p>-X 选项是非标准选项。如有更改，恕不另行通知。</p></li><li><h3 id="XX参数选项"><a href="#XX参数选项" class="headerlink" title="-XX参数选项"></a>-XX参数选项</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>布尔类型 : -XX +<option> 启用 -XX -<option> 停用</li><li>非布尔类型：-XX:name&#x3D;value</li></ul></li></ul><h2 id="2-添加JVM参数选项"><a href="#2-添加JVM参数选项" class="headerlink" title="2. 添加JVM参数选项"></a>2. 添加JVM参数选项</h2><ul><li><h3 id="IDEA："><a href="#IDEA：" class="headerlink" title="IDEA："></a>IDEA：</h3><ul><li>点击配置运行环境，打开VM选项即可输入</li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051424366.png" alt="image-20210711205033973"></p></li><li><h3 id="运行jar包："><a href="#运行jar包：" class="headerlink" title="运行jar包："></a>运行jar包：</h3><ul><li>java &lt;参数&gt; -jar demo.jar</li></ul></li><li><h3 id="通过Tomcat运行："><a href="#通过Tomcat运行：" class="headerlink" title="通过Tomcat运行："></a>通过Tomcat运行：</h3><ul><li>catalina.bat中添加：set “JAVA_OPTS&#x3D;-Xms100m -Xmx100m”</li></ul></li></ul><h2 id="3-常用的JVM参数选项"><a href="#3-常用的JVM参数选项" class="headerlink" title="3. 常用的JVM参数选项"></a>3. 常用的JVM参数选项</h2><h3 id="打印设置的参数"><a href="#打印设置的参数" class="headerlink" title="打印设置的参数"></a>打印设置的参数</h3><ul><li>-XX:+PrintCommandLineFlags 表示程序运行前打印出JVM参数</li><li>-XX:+PrintFlagsInitial 表示打印出所有参数的默认值</li><li>-XX:+PrintFlagsFinal 打印出最终的参数值</li><li>-XX:+PrintVMOptions 打印JVM的参数</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>-Xss128k</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>-Xms600m 设置堆的初始大小</li><li>-Xmx600m 设置堆的最大大小</li><li>-XX:NewSize&#x3D;1024m 设置年轻代的初始大小</li><li>-XX:MaxNewSize&#x3D;1024m 设置年轻代的最大值</li><li>-XX:SurvivorRatio&#x3D;8 伊甸园和幸存者的比例</li><li>-XX:NewRatio&#x3D;4 设置老年代和新生代的比例</li><li>-XX:MaxTenuringThreshold&#x3D;15 设置晋升老年代的年龄条件</li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul><li>永久代<ul><li>-XX:PermSize&#x3D;256m 设置永久代初始大小</li><li>-XX:MaxPernSize&#x3D;256m 设置永久代的最大大小</li></ul></li><li>元空间<ul><li>-XX:MetasapceSize&#x3D;256m 设置初始元空间大小</li><li>-XX:MaxMatespaceSize&#x3D;256m 设置最大元空间大小 默认无限制</li></ul></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul><li>-XX:MaxDirectMemorySize 设置直接内存的容量，默认与堆最大值一样。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-监控及诊断工具-命令行篇</title>
      <link href="/JVM-%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87/"/>
      <url>/JVM-%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM监控及诊断工具-命令行篇"><a href="#JVM监控及诊断工具-命令行篇" class="headerlink" title="JVM监控及诊断工具-命令行篇"></a>JVM监控及诊断工具-命令行篇</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>​ 性能诊断是软件工程师在日常工作中经常要面对和解决的问题，在用户体验至上的今天，解决好应用的i性能问题能带来巨大的收益。</p><p>​ Java作为最流行的编程语言之一，其应用性能诊断一直受到业界的广泛关注。可能造成Java应用出现性能问题的因素非常多，比如</p><ul><li><p>线程控制</p></li><li><p>磁盘读写</p></li><li><p>数据库访问</p></li><li><p>网络IO</p></li><li><p>垃圾收集</p><p>要想定位这些问题，一款优秀的性能诊断工具必不可少。</p></li></ul><h2 id="二-jps-（Java-Process-Status）查看正在运行的Java进程"><a href="#二-jps-（Java-Process-Status）查看正在运行的Java进程" class="headerlink" title="二 jps （Java Process Status）查看正在运行的Java进程"></a>二 jps （Java Process Status）查看正在运行的Java进程</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p>-q: 仅显示ID</p></li><li><p>-l 输出程序的全限定名</p></li><li><p>-m 输出进程启动时传递给main的参数</p></li><li><p>-v 列出JVM参数</p></li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>​ 如果Java进程关闭了默认开启的<code>UserPerfData</code>参数，则jps无法探测。</p><h2 id="三-jstat-JVM统计信息"><a href="#三-jstat-JVM统计信息" class="headerlink" title="三 jstat JVM统计信息"></a>三 jstat JVM统计信息</h2><ul><li><p>jstat 用于监视虚拟机各种运行状态信息，比如类装载，内存，GC，JIT编译等。</p><ul><li><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master//images/image-20210721111927416.png" alt="image-20210721111927416"></li></ul></li><li><p>option</p><ul><li><p>-class 显示ClassLoader的相关信息</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709211950837.png" alt="image-20210709211950837"></p></li><li><p>-gc 显示与GC相关的堆信息</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709212834651.png" alt="image-20210709212834651"></p><p>后缀C表示容量 后缀U表示已使用 后缀T表示耗时</p></li><li><p>-gccapacity: 显示内容与-gc基本相同，但是输出主要关注堆各个区域最大最小空间</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709212200853.png" alt="image-20210709212200853"></p></li><li><p>-gcutil :关注已使用占总空间的比例</p></li><li><p>-gcnew 显示新生代的情况</p></li><li><p>-gcold 显示老年代的情况</p></li><li><p>-gccause 与gcutil输出一样，最后多显示最后一次发生GC的原因</p></li><li><p>-compiler: 显示JIT编译器编译过的方法 耗时等</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709212105500.png" alt="image-20210709212105500"></p></li><li><p>-printcompilation: 输出已经被JIT编译过的方法</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709212138907.png" alt="image-20210709212138907"></p></li></ul></li><li><p>-t 表示在输出信息前加时间戳 表示程序的运行时间 单位 s</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709211313491.png" alt="image-20210709211313491"></p></li></ul><p>-h 表示多少行内容之后输入一次表头信息</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709211357039.png" alt="image-20210709211357039"></p><ul><li><p>interval 指定更新统计数据的周期，单位ms 每隔n毫秒输入一次</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709211436477.png" alt="image-20210709211436477"></p></li></ul><p>count 与上个参数 配合使用 表示一共输出多少次 空表示一直输出</p><h2 id="四-jinfo-查看和修改JVM配置参数"><a href="#四-jinfo-查看和修改JVM配置参数" class="headerlink" title="四 jinfo 查看和修改JVM配置参数"></a>四 jinfo 查看和修改JVM配置参数</h2><blockquote><p>jinfo <option> <pid></p></blockquote><ul><li><p>option</p><ul><li><p>查看</p><ul><li>jinfo -sysprpos pid ：查看该进程的全部配置信息</li><li>jinfo -flag 参数名 pid： 查看指定参数值</li></ul><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210709214801604.png" alt="image-20210709214801604"></p><ul><li>-flag &lt;具体参数&gt; pid： 查看具体参数的值</li></ul></li><li><p>修改</p><ul><li>布尔类型: jinfo -flag +-参数 pid</li><li>非布尔类型: jinfo -flag 参数名&#x3D;参数值 pid</li></ul></li></ul></li></ul><h2 id="五-jmap-导出内存映像文件-amp-内存使用情况"><a href="#五-jmap-导出内存映像文件-amp-内存使用情况" class="headerlink" title="五 jmap 导出内存映像文件&amp;内存使用情况"></a>五 jmap 导出内存映像文件&amp;内存使用情况</h2><h2 id="六-jhat-JDK自带的堆分析工具"><a href="#六-jhat-JDK自带的堆分析工具" class="headerlink" title="六 jhat JDK自带的堆分析工具"></a>六 jhat JDK自带的堆分析工具</h2><h2 id="七-jstack-打印JVM中的线程快照"><a href="#七-jstack-打印JVM中的线程快照" class="headerlink" title="七 jstack 打印JVM中的线程快照"></a>七 jstack 打印JVM中的线程快照</h2><h2 id="八-jcmd-多功能命令行"><a href="#八-jcmd-多功能命令行" class="headerlink" title="八 jcmd 多功能命令行"></a>八 jcmd 多功能命令行</h2><blockquote><p>在JDK1.7之后，新增了一个命令行工具jcmd ，它是一个多功能的工具，实现之前的所有功能。</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li><p>jcmd -l 列出所有的Java进程</p><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711132042497.png" alt="image-20210711132042497"></p></li><li><p>jcmd pid help : 列出所有可用的指令</p><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711132310412.png" alt="image-20210711132310412"></p></li><li><p>jcmd pid 命令（上图中可选的命令均可）</p><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711132941235.png" alt="image-20210711132941235"></p></li></ul><h2 id="九-jstatd-远程主机信息收集"><a href="#九-jstatd-远程主机信息收集" class="headerlink" title="九 jstatd 远程主机信息收集"></a>九 jstatd 远程主机信息收集</h2><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711133144394.png" alt="image-20210711133144394"></p><blockquote><p>通过jstatd 可以建立本地计算机与远程监控工具的通信。jstatd将本机的Java应用程序信息传递给远程计算机。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-监控及诊断工具-GUI篇</title>
      <link href="/JVM-%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI%E7%AF%87/"/>
      <url>/JVM-%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM监控及诊断工具-GUI篇"><a href="#JVM监控及诊断工具-GUI篇" class="headerlink" title="JVM监控及诊断工具-GUI篇"></a>JVM监控及诊断工具-GUI篇</h1><h2 id="一-工具概述"><a href="#一-工具概述" class="headerlink" title="一 .工具概述"></a>一 .工具概述</h2><h4 id="JDK自带的GUI工具"><a href="#JDK自带的GUI工具" class="headerlink" title="JDK自带的GUI工具"></a>JDK自带的GUI工具</h4><pre><code>- JConsole- VisualVM- JMC</code></pre><h4 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h4><ul><li><p>MAT</p></li><li><p>Jprofiler</p></li><li><p>Arthas</p></li><li><p>Btrace</p><p>……</p></li></ul><h2 id="二-JConsole"><a href="#二-JConsole" class="headerlink" title="二 .JConsole"></a>二 .JConsole</h2><h4 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h4><p>从 Java5开始，JDK自带的Java监控和管理控制台。</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>cmd jconsole或者在jdk bin目录下执行即可</p><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711134709831.png" alt="image-20210711134709831"></p><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711134820795.png" alt="image-20210711134820795"></p><h2 id="三-Visual-VM"><a href="#三-Visual-VM" class="headerlink" title="三 .Visual VM"></a>三 .Visual VM</h2><blockquote><p>一个功能强大的集合-故障诊断和性能监控的可视化工具</p></blockquote><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>cmd jconsole或者在jdk bin目录下执行即可</p><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711141155159.png" alt="image-20210711141155159"></p><h4 id="监控-1"><a href="#监控-1" class="headerlink" title="监控"></a>监控</h4><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711141609971.png" alt="image-20210711141609971"></p><h2 id="四-eclipse-MAT"><a href="#四-eclipse-MAT" class="headerlink" title="四 . eclipse MAT"></a>四 . eclipse MAT</h2><blockquote><p>需要JDK11之后，由于我的JDK版本不支持，此处略</p></blockquote><h2 id="五-Jprofiler"><a href="#五-Jprofiler" class="headerlink" title="五. Jprofiler"></a>五. Jprofiler</h2><blockquote><p>软件下载地址: <a href="https://www.jb51.net/softs/608640.html#downintro2">JProfiler11免费版下载</a></p></blockquote><p>IDEA插件: <a href="https://plugins.jetbrains.com/files/253/122553/idea-jprofiler.zip?updateId=122553&pluginId=253&family=INTELLIJ">下载地址</a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>使用方便，界面操作友好</p></li><li><p>对被分析的应用影响小</p></li><li><p>CPU，Thread，Memory分析功能强大</p></li><li><p>支持对JDBC，jsp,servlet,socket等分析</p></li><li><p>支持多种模式</p></li><li><p>支持远程JVM</p></li><li><p>跨平台，支持多种系统</p><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711175613452.png" alt="image-20210711175613452"></p></li></ul><h3 id="数据采集方式"><a href="#数据采集方式" class="headerlink" title="数据采集方式"></a>数据采集方式</h3><ul><li><p>Instrumentation重构模式</p><p>在class文件加载之前，将相关的统计功能代码写入到class中，对正在运行的JVM有影响。</p><ul><li>优点：调用堆栈信息准确</li><li>缺点：如果分析的类较多，则CPU开销较高。此模式配合Filter使用。</li></ul></li><li><p>Sampling抽样模式</p><p>一定时间将每个线程栈中方法栈的信息统计出来</p><ul><li>优点：对应用影响小</li><li>缺点： 一些数据无法提供</li></ul></li></ul><h2 id="六-Arthas（阿里巴巴）"><a href="#六-Arthas（阿里巴巴）" class="headerlink" title="六. Arthas（阿里巴巴）"></a>六. Arthas（阿里巴巴）</h2><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711201632574.png" alt="image-20210711201632574"></p><blockquote><p>阿尔萨斯，是Alibaba开源的Java诊断工具，在线排查问题，无需重启，动态跟踪Java代码，实时监控JVM状态。</p></blockquote><h3 id="官方地址"><a href="#官方地址" class="headerlink" title="官方地址"></a><a href="https://arthas.aliyun.com/zh-cn/">官方地址</a></h3><h2 id="七-关于内存泄漏"><a href="#七-关于内存泄漏" class="headerlink" title="七. 关于内存泄漏"></a>七. 关于内存泄漏</h2><p>可达性分析算法来判断对象是否是不再使用的对象，本质是判断一个对象是否还被引用，由于代码的实现不同就会出现很多种内存泄漏问题。</p><h4 id="内存泄露的理解"><a href="#内存泄露的理解" class="headerlink" title="内存泄露的理解"></a>内存泄露的理解</h4><ul><li>严格来说，只有对象不再被程序使用，但是GC又不能回收的情况叫做内存泄露</li><li>实际上，很多时候一些不好的编程习惯会使得某些对象的生命周期变的很长，比如局部变量定义为类变量，类变量定义为静态变量，此时，可能会导致OOM，这种也可以叫做宽泛意义上的<code>内存泄露</code></li><li>比如</li></ul><p><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/image-20210711170026972.png" alt="image-20210711170026972"></p><ul><li>内存泄漏过多，就会导致内存溢出</li></ul><h4 id="演示内存泄漏并排查问题"><a href="#演示内存泄漏并排查问题" class="headerlink" title="演示内存泄漏并排查问题"></a>演示内存泄漏并排查问题</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">演示内存泄漏</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不加此行代码 容易造成内存泄漏</span></span><br><span class="line">        <span class="comment">//elements[size] = null;</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中出栈操作只是将当前位置下移，；出栈的对象并未置Null,此时，指向的对象无法被GC回收</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>在返回出栈对象之前，将该对象置空 即加入 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        Object result=elements[--size];</span><br><span class="line">        elements[size]=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-性能优化概述</title>
      <link href="/JVM-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/"/>
      <url>/JVM-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="性能优化概述"><a href="#性能优化概述" class="headerlink" title="性能优化概述"></a>性能优化概述</h1><h2 id="一-背景说明"><a href="#一-背景说明" class="headerlink" title="一 背景说明"></a>一 背景说明</h2><ol><li><h3 id="生产环境中出现的问题"><a href="#生产环境中出现的问题" class="headerlink" title="生产环境中出现的问题"></a>生产环境中出现的问题</h3><ul><li>发生内存泄漏如何处理？</li><li>给服务器分配多少内存合适？</li><li>如何对垃圾回收器进行性能调优？</li><li>生产环境中CPU负载过高如何处理？</li><li>生产环境该给应用分配多少线程？</li><li>不加log，如何确定请求执行到了某一行代码？</li><li>不加log，如何实时查看某个方法的入参与返回值？</li></ul></li><li><h3 id="为什么要调优？"><a href="#为什么要调优？" class="headerlink" title="为什么要调优？"></a>为什么要调优？</h3><ul><li>防止出现OOM</li><li>解决OOM</li><li>减少Full GC的频率</li></ul></li><li><h3 id="不同阶段的考虑"><a href="#不同阶段的考虑" class="headerlink" title="不同阶段的考虑"></a>不同阶段的考虑</h3><ul><li>上线前</li><li>运行阶段</li><li>线上出现OOM</li></ul></li></ol><h2 id="二-调优概述"><a href="#二-调优概述" class="headerlink" title="二 调优概述"></a>二 调优概述</h2><ol><li><h3 id="监控的依据"><a href="#监控的依据" class="headerlink" title="监控的依据"></a>监控的依据</h3><ul><li>运行日志</li><li>异常堆栈</li><li>GC日志</li><li>线程快照</li><li>堆转存快照</li></ul></li><li><h3 id="调优的大方向"><a href="#调优的大方向" class="headerlink" title="调优的大方向"></a>调优的大方向</h3><ul><li>合理编写代码</li><li>充分并合理使用硬件资源</li><li>合理的进行JVM调优</li></ul></li></ol><h2 id="四-性能优化的步骤"><a href="#四-性能优化的步骤" class="headerlink" title="四 性能优化的步骤"></a>四 性能优化的步骤</h2><ol><li><h3 id="发现问题（性能监控）"><a href="#发现问题（性能监控）" class="headerlink" title="发现问题（性能监控）"></a>发现问题（性能监控）</h3><ul><li>GC频率</li><li>CPU负载过高</li><li>OOM</li><li>内存泄漏</li><li>死锁</li><li>响应时间过长</li></ul></li><li><h3 id="排查问题（性能分析）"><a href="#排查问题（性能分析）" class="headerlink" title="排查问题（性能分析）"></a>排查问题（性能分析）</h3><ul><li>打印GC日志，分析GC日志</li><li>导出dump文件 进行分析</li><li>使用第三方的工具查看JVM状态</li><li>jstack查看堆栈信息</li></ul></li><li><h3 id="解决问题（性能调优）"><a href="#解决问题（性能调优）" class="headerlink" title="解决问题（性能调优）"></a>解决问题（性能调优）</h3><ul><li>增加内存 根据业务背景选择GC器</li><li>优化代码 控制内存使用</li><li>增加机器，分散节点压力</li><li>合理设置线程数量</li><li>使用中间件提高效率，缓存，消息队列等</li></ul></li></ol><h2 id="五-性能评价-x2F-测试指标"><a href="#五-性能评价-x2F-测试指标" class="headerlink" title="五 性能评价&#x2F;测试指标"></a>五 性能评价&#x2F;测试指标</h2><ol><li><h3 id="停顿时间"><a href="#停顿时间" class="headerlink" title="停顿时间"></a>停顿时间</h3><ul><li>定义：</li></ul><p>​ 提交请求和返回响应之间的时间，（一般关注平均值）</p><ul><li>在垃圾回收时，STW的时间。</li></ul></li><li><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li>对单位时间内完成的工作量的量度</li><li>在GC中，表示用户代码执行时间占总运行时间的比例。</li></ul></li><li><h3 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h3><ul><li>同一时刻，对服务器有实际交互的请求数</li></ul></li><li><h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><ul><li>堆所占的内存大小</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-垃圾回收器</title>
      <link href="/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="一-GC的分类与性能指标"><a href="#一-GC的分类与性能指标" class="headerlink" title="一 GC的分类与性能指标"></a>一 GC的分类与性能指标</h2><ol><li><h3 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h3><ul><li><strong>串行垃圾回收器</strong> 但CPU，配置较低，只有一条GC线程</li><li><strong>并行垃圾回收器</strong> 并发较强的CPU 多条GC</li><li><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422459.png" alt="image-20210705091315353"></li></ul></li><li><h3 id="按照工作模式"><a href="#按照工作模式" class="headerlink" title="按照工作模式"></a><strong>按照工作模式</strong></h3><ul><li><p><strong>并发式垃圾回收器</strong></p><p>与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</p></li><li><p><strong>独占式垃圾回收器</strong></p><p>一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</p></li><li><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422422.png" alt="image-20210705094131829"></p></li></ul></li><li><h3 id="按碎片处理方式"><a href="#按碎片处理方式" class="headerlink" title="按碎片处理方式"></a><strong>按碎片处理方式</strong></h3><ul><li><p><strong>压缩式垃圾回收器</strong></p><p>​ 回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p></li><li><p><strong>非压缩式垃圾回收器</strong></p><p>​ 非回收碎片，再创建对象使用空闲列表。</p></li></ul></li><li><p><strong>按工作的内存区间分</strong></p><ul><li><strong>年轻代垃圾回收器</strong></li><li><strong>老年代垃圾回收器</strong></li></ul></li></ol><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><p>&#x3D;&#x3D;吞吐量：运行用户代码的时间占总运行时间的比例&#x3D;&#x3D;</p><ul><li><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间&#x2F; （运行用户代码时间+垃圾收集时间）</p><ul><li>➢比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</li></ul></li><li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p></li><li><p>**&#x3D;&#x3D;吞吐量优先，意味着在单位时间内，STW的时间最短&#x3D;&#x3D;**： 0.2 + 0.2 &#x3D; 0.4</p></li></ul></li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422901.png" alt="image-20210705095526753"></p><ul><li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p></li><li><p><strong>&#x3D;&#x3D;暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间&#x3D;&#x3D;</strong></p><ul><li><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p><ul><li>➢例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。.</li></ul></li><li><p>**&#x3D;&#x3D;暂停时间优先，意味着尽可能让单次STW的时间最短&#x3D;&#x3D;**： 0.1 + 0.1 + 0.1 + 0.1+0.1&#x3D;0.5</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422251.png" alt="image-20210705095558002"></p></li></ul></li><li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p></li><li><p>&#x3D;&#x3D;内存占用： Java堆区所占的内存大小&#x3D;&#x3D;</p></li><li><p>快速：一个对象从诞生到被回收所经历的时间。</p></li><li><p>高亮部分共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p></li><li><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用 多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p></li></ul><h2 id="二-不同的垃圾回收器概述"><a href="#二-不同的垃圾回收器概述" class="headerlink" title="二 不同的垃圾回收器概述"></a>二 不同的垃圾回收器概述</h2><h3 id="1-垃圾回收器发展史"><a href="#1-垃圾回收器发展史" class="headerlink" title="1. 垃圾回收器发展史"></a>1. 垃圾回收器发展史</h3><ul><li><p>1999年随JDK1.3.1一 起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</p></li><li><p>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布</p></li><li><p>Parallel GC在JDK6之后成为HotSpot默认GC。</p></li><li><p>2012年，在JDK1.7u4版本中，G1可用。</p></li><li><p>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</p></li><li><p>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</p></li></ul><p>—————– 分水岭 ———————</p><ul><li><p>2018年9月，JDK11发布。引入Epsilon垃圾回收器，又被称为”No一0p （无操作） “回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。</p></li><li><p>2019年3月，JDK12发布。 增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC （Experimental）。</p></li><li><p>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</p></li><li><p>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows.上的应用</p></li></ul><h3 id="2-七款经典的垃圾回收器"><a href="#2-七款经典的垃圾回收器" class="headerlink" title="2. 七款经典的垃圾回收器"></a>2. 七款经典的垃圾回收器</h3><ul><li>串行回收器：Serial. Serial Old</li><li>并行回收器：ParNew. Parallel Scavenge. Parallel Old</li><li>并发回收器：CMS. G1</li><li><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422022.png" alt="image-20210705101934780"></li></ul><h3 id="3-七款经典的垃圾收集器与垃圾分代之间的关系"><a href="#3-七款经典的垃圾收集器与垃圾分代之间的关系" class="headerlink" title="3. 七款经典的垃圾收集器与垃圾分代之间的关系"></a>3. 七款经典的垃圾收集器与垃圾分代之间的关系</h3><ul><li>新生代收集器： Serial、 ParNeW、Parallel Scavenge</li><li>老年代收集器： Serial 0ld、 Parallel 0ld、 CMS</li><li>整堆收集器： G1</li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422657.png" alt="image-20210705102026012"></p><h3 id="4-垃圾收集器的组合关系"><a href="#4-垃圾收集器的组合关系" class="headerlink" title="4. 垃圾收集器的组合关系"></a>4. 垃圾收集器的组合关系</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422357.png" alt="image-20210705102141253"></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>JDK1.3到1.5默认使用SerialGC + SerialOldGC</li><li>JDK1.6到1.8默认是ParallerlGC + parallerlOldGC</li><li>JDK9及以后默认使用G1</li><li>CMS在9之后过期，14之后被移除</li></ul><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ol><li>两个收集器间有连线，表明它们可以搭配使用</li><li>其中Serial 0ld作为CMS 出现”Concurrent Mode Failure”失败的后 备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，JDK8过时，JDK 9中移除。</li><li>（绿色虚线）JDK 14中：过时 未来会移除</li><li>（青色虚线）JDK 14中：删除CMS垃圾回收器</li></ol><ul><li>为什么要有很多收集器个不够吗？ 因为Java的使用场景很多， 移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</li><li>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器</li></ul><ol start="5"><li><h3 id="查看默认的垃圾收集器"><a href="#查看默认的垃圾收集器" class="headerlink" title="查看默认的垃圾收集器"></a><strong>查看默认的垃圾收集器</strong></h3><ul><li>-XX：+PrintCommandLineFlags： 查看命令行相关参数（包含使用的垃圾收集器）<ul><li>JDK1.8结果:  +UseParallelGC +UseParallelOldGC</li><li>JDK11结果：+UseG1GC</li></ul></li><li>使用命令行指令： jinfo -flag相关垃圾回收器参数进程ID</li></ul></li></ol><h2 id="三-Serial回收器（串行回收）"><a href="#三-Serial回收器（串行回收）" class="headerlink" title="三 Serial回收器（串行回收）"></a>三 Serial回收器（串行回收）</h2><h3 id="SerialGC"><a href="#SerialGC" class="headerlink" title="SerialGC"></a>SerialGC</h3><ul><li>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</li><li>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</li><li>&#x3D;&#x3D;Serial收集器采用复制算法、串行回收和”Stop一 the一World”机制的方式执行内存回收。&#x3D;&#x3D;</li></ul><h3 id="SerialOldGC"><a href="#SerialOldGC" class="headerlink" title="SerialOldGC"></a>SerialOldGC</h3><ul><li>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial 0ld收集器。 Serial Old收集器同样也采用了串行回收 和”Stop the World”机制，只不过内存回收算法使用的是&#x3D;&#x3D;标记压缩算法&#x3D;&#x3D;。</li><li>➢Serial 0ld是运行在Client模式下默认的老年代的垃圾回收器。</li><li>➢Serial 0ld在服务端（Linux）下主要有两个用途：<ul><li>①与新生代的ParallelScavenge配合使用;</li><li>②作为老年代CMS收集器的后备垃圾收集方案</li></ul></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World ）。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422073.png" alt="image-20210705201814064"></p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Seria1收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p></li><li><p>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB）， 可以在较短时间内完成垃圾收集（几十ms至一百多ms） ，只要不频繁发生，使用串行回收器是可以接受的。</p></li><li><p>在HotSpot虛拟机中，使用<code>-XX：+UseSerialGC </code>表示年轻代使用SerialGC和老年代使用SerialOldGC收集器。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。</li><li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Javaweb应用程序中是不会采用串行垃圾收集器的。</li></ul><h2 id="四-ParNew回收器（并行回收）"><a href="#四-ParNew回收器（并行回收）" class="headerlink" title="四 ParNew回收器（并行回收）"></a>四 ParNew回收器（并行回收）</h2><blockquote><p>ParNew是上一个Serial的多线程版本</p></blockquote><ul><li><p>ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用&#x3D;&#x3D;复制算法&#x3D;&#x3D;、老年代同样采用&#x3D;&#x3D;标记压缩算法&#x3D;&#x3D;。”Stop一 the一World”机制。</p></li><li><p>ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p></li><li><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051423968.png" alt="image-20210705203727535"></p></li><li><p>对于新生代，回收次数频繁，使用并行方式高效。</p><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行 需要切换线程，串行可以省去切换线程的资源）</p><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p><ul><li>➢ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、 多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>➢但是在单个CPU的环境下，ParNew收 集器不比Serial收集器更高 效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul><p>因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p></li><li><p>在程序中，开发人员可以通过选项<code>-XX： +UseParNewGC</code>手动指定使用.ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p></li><li><p>&#96;&#96;-XX：ParallelGCThreads&#96;限制线程数量，默认开启和CPU数据相同的线程数。</p></li></ul><h2 id="五-Parallel回收器（吞吐量优先）"><a href="#五-Parallel回收器（吞吐量优先）" class="headerlink" title="五 Parallel回收器（吞吐量优先）"></a>五 Parallel回收器（吞吐量优先）</h2><blockquote><p>Parallel Scavenge收集器的目标是&#x3D;&#x3D;达到一个可控制的吞吐量&#x3D;&#x3D;（Throughput），它也被称为吞吐量优先的垃圾收集器。</p></blockquote><ul><li><p>➢&#x3D;&#x3D;自适应调节策略&#x3D;&#x3D;也是Parallel Scavenge 与ParNew一个重要区别。</p></li><li><p>高吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务，主 要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p></li><li><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的 Parallel 0ld收集器，用来代替老年代的Serial 0ld收集器。</p></li><li><p>Parallel 0ld收集器采用了&#x3D;&#x3D;标记一压缩&#x3D;&#x3D;算法，但同样也是基于并行回收和”Stop一the一World”机制。</p></li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051423099.png" alt="image-20210705204714966"></p><ul><li>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld收集器的组合，在Server模式下的内存回收性能很不错。</li><li><strong>在Java8中，默认是此垃圾收集器</strong></li></ul><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul><li><p>-XX:MAxGCPauseMillis 设置垃圾回收器的最大停顿时间（STW时间）单位ms</p><ul><li>为了尽可能的将STW控制在xms内，收集器会调整应堆的大小或一些其他参数 比如STW小，则堆也小</li><li>对于用户来讲停顿的时间越少越好，但是在服务端，注重高并发，整体的吞吐量。所以服务端更加适合Parallel 进行控制</li></ul></li><li><p>-XX:GCTimeRatio 垃圾回收时间占总时间的比例</p><ul><li>默认为99 即垃圾回收时间不超过1%</li></ul></li><li><p>-XX:+UseAdaptiveSizePolicy 是否开启具有自适应调节</p><ul><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年 代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指 定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</li></ul></li></ul><h2 id="六-CMS回收器（低延迟）-9废弃，14移除"><a href="#六-CMS回收器（低延迟）-9废弃，14移除" class="headerlink" title="六 CMS回收器（低延迟）(9废弃，14移除)"></a>六 CMS回收器（低延迟）(9废弃，14移除)</h2><ul><li><p>在JDK1.5时期， HotSpot推出了一款在强交互应用中几乎可认为有划 时代意义的垃圾收集器： CMS - （Concurrent -Mark -Sweep）收集器，<br>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p></li><li><p>CMS收集器的关注点是<code>尽可能缩短垃圾收集时用户线程的停顿时间</code>。停顿时 间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p></li><li><p>➢目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p></li><li><p>不幸的是，CMS 作为老年代的收集器，却无法与JDK 1.4.0 中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.<br>5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p></li><li><p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p></li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051423391.png" alt="image-20210706093959717"></p><ul><li><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段</p><ul><li><p>初始标记（Initial一Mark） 阶段：在这个阶段中，程序中所有的工作线程都将会因为. “Stop一the一World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是&#x3D;&#x3D;标记出GCRoots能直接关联到的对象&#x3D;&#x3D;。<br>一旦标记完成之后就会恢复之前被暂停的所有应用.线程。由于直接关联对象比较小，所以这里的速度非常快。</p></li><li><p>并发标记（Concurrent一Mark）阶段：<code>从GC Roots的 直接关联对象开始遍历整个对象图</code>的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p></li><li><p>重新标记（Remark） 阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<code>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</code><br>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，<br>但也远比并发标记阶段的时间短。</p></li><li><p>并发清除（ Concurrent一Sweep）阶段：此阶段&#x3D;&#x3D;清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。&#x3D;&#x3D;由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p></li><li></li></ul></li><li><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop一the一World”机制暂停程序中的工作线程，不过暂停时间并不会太长，<br>因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop一the一World”，只是尽可能地缩短暂停时间。</p></li></ul><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以<code>整体的回收是低停顿的</code>。</p><ul><li><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，<br>而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，<br>这时虚拟机将启动后备预案：临时启用Serial 0ld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p></li><li><p>CMS收集器的垃圾收集算法采用的是<code>标记清除算法</code>，这意味着每次执行完内存回收后，<br>由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。<br>那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer） 技术，<br>而只能够选择空闲列表（Free List） 执行内存分配。</p></li><li><p><strong>既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？</strong><br>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the<br>World”这种场景”下使用</p></li><li><h3 id="CMS的优点："><a href="#CMS的优点：" class="headerlink" title="CMS的优点："></a>CMS的优点：</h3><ul><li>并发收集</li><li>低延迟</li></ul></li></ul><h3 id="CMS的弊端："><a href="#CMS的弊端：" class="headerlink" title="CMS的弊端："></a>CMS的弊端：</h3><ul><li>1）<code>会产生内存碎片</code>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li><li>2） <code>CMS收集器对CPU资源非常敏感</code>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>3） <code>CMS收集器无法处理浮动垃圾</code>。可能出现“Concurrent Mode Failure” 失败而导致另一次Full GC的产生。<br>在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，<br>CMS将 无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><h3 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h3><ul><li><p>一XX：+UseConcMarkSweepGC 使用CMS收集器</p><ul><li>➢开启该参数后会自动将一XX： +UseParNewGc打开。即： ParNew （Young区用） +CMS （0ld区用） +Serial 0ld(备选)的组合。</li></ul></li><li><p>一XX：CMS1ni tiatingOccupanyFraction设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p><ul><li>JDK5及以前版本的默认值为68</li><li>JDK6及以上版本默认值为92</li><li>➢如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。<br>反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</li></ul></li><li><p>一XX： +UseCMSCompactAtFullCollection用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p></li><li><p>一XX：CMSFullGCsBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理。</p></li><li><p>一XX：ParallelCMSThreads 设置CMS的线程数量。</p><ul><li>CMS 默认启动的线程数是（ParallelGCThreads+3)&#x2F;4，<br>ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li><li><h3 id="判断使用哪种垃圾回收器"><a href="#判断使用哪种垃圾回收器" class="headerlink" title="判断使用哪种垃圾回收器"></a>判断使用哪种垃圾回收器</h3><ul><li>如果你想要<code>最小化地使用内存和并行开销</code>，请选Serial GC；老年代默认使用SerialOld</li><li>如果你想要<code>最大化应用程序的吞吐量</code>，请选Parallel GC；老年代默认使用ParallelOld</li><li>如果你想要<code>最小化GC的中断或停顿时间</code>，请选CMS GC。老年代默认使用ParNew 备选 SerialOld</li></ul></li></ul><h2 id="七-G1回收器：分区-x2F-垃圾优先"><a href="#七-G1回收器：分区-x2F-垃圾优先" class="headerlink" title="七 G1回收器：分区&#x2F;垃圾优先"></a>七 G1回收器：分区&#x2F;垃圾优先</h2><h3 id="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First-（G1）GC？"><a href="#既然我们已经有了前面几个强大的GC，为什么还要发布Garbage-First-（G1）GC？" class="headerlink" title="既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？"></a><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First （G1）GC？</strong></h3><p>​ 原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1 （Garbage一First） 垃圾回收器是在Java7<br>update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。<br>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time） ，同时兼顾良好的吞吐量。<br>官方给G1设定的目标是<code>在延迟可控（STW）的情况下获得尽可能高的吞吐量</code>，所以才担当起“全功能收集器”的重任与期望。</p><ul><li>​ 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region） （物理上 不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li><li>​ G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1跟踪各个Region<br>里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间），在后台维护一个优先列表，每次&#x3D;&#x3D;根据允许的收集时间，优先回收价值最大的Region&#x3D;&#x3D;。</li><li>​ 由于这种方式的侧重点在于区间中垃圾数目，所以我们给G1一个名字：垃圾优先（Garbage First）</li><li>​ G1 （Garbage一First） 是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，&#x3D;&#x3D;以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。&#x3D;&#x3D;</li><li>​ 在JDK1. 9版本正式启用，被Oracle官方称为“全功能的垃圾收集器” 。</li><li>​ 与此同时，CMS已经在JDK 9中被标记为废弃（deprecated） 。在jdk8中还不是默认的垃圾回收器，需要使用一XX： +UseG1GC来启用。</li></ul><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ul><li><h4 id="兼具并行与并发"><a href="#兼具并行与并发" class="headerlink" title="兼具并行与并发"></a>兼具并行与并发</h4><ul><li>➢并行性： G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>➢并发性： G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul><li>➢从分代上看，&#x3D;&#x3D;G1依然属于分代型垃圾回收器&#x3D;&#x3D;，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构，上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>➢将堆空间分为若干个区域（Region） ，这些区域中包含了逻辑上的年轻代和老年代。</li><li>➢和之前的各类回收器不同，&#x3D;&#x3D;它同时兼顾年轻代和老年代。&#x3D;&#x3D;</li></ul></li><li><h4 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h4><ul><li>➢CMS： “标记一清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>➢G1将内存划分为一个个的region。<br>内存的回收是以region作为基本单位的.Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark一Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul></li><li><h4 id="x3D-x3D-可预测的停顿时间模型-x3D-x3D"><a href="#x3D-x3D-可预测的停顿时间模型-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;可预测的停顿时间模型&#x3D;&#x3D;"></a>&#x3D;&#x3D;可预测的停顿时间模型&#x3D;&#x3D;</h4><ul><li>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li><li>➢由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>➢G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以 及回收所需时间的经验值），在后台维护一个优先列表，&#x3D;&#x3D;每次根据允许的收集时间，优先回收价值最大的Region。保证了G1<br>收集器在有限的时间内可以获取尽可能高的收集效率。&#x3D;&#x3D;</li><li>➢相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要.好很多。</li></ul></li><li><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint） 还是程序运行时的额外执行负载（overload） 都要比CMS要高。</li><li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用，上则发挥其优势。平衡点在6-8GB之间。</li></ul></li></ul><h3 id="G1回收器的过程"><a href="#G1回收器的过程" class="headerlink" title="G1回收器的过程"></a>G1回收器的过程</h3><ul><li><p>年轻代GC （Young GC ）</p></li><li><p>老年代并发标记过程（ Concurrent Marking）</p></li><li><p>混合回收（Mixed GC ）</p></li><li><p>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051423312.png" alt="image-20210818090636748"></p></li></ul><h3 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h3><ul><li>一XX：+UseG1GC 手动指定使用G1收集器执行内存回收任务。</li><li>一XX：G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围是1MB 到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</li><li>一XX：MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</li><li>一xX：ParallelGCThread 设置sTw.工作线程数的值。最多设置为8</li><li>一XX：ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4左右。</li><li>一XX：Ini tiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li></ul><h3 id="G1回收器的常见操作步骤"><a href="#G1回收器的常见操作步骤" class="headerlink" title="G1回收器的常见操作步骤"></a>G1回收器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1中提供了三种垃圾回收模式： YoungGC、 Mixed GC和Full GC， 在不同的条件下被触发。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>面向服务端应用，针对具有大内存、多处理器的机器。</li><li>最主要的应用是&#x3D;&#x3D;需要低GC延迟，并具有大堆的应用程序提供解决方案；&#x3D;&#x3D;</li><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； （ G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li><li>用来替换掉JDK1.5中的CMS收集器； 在下面的情况时，使用G1可能比CMS好：<br>①超过50%的Java堆被活动数据占用；<br>②对象分配频率或年代提升频率变化很大；<br>③GC停顿时间过长（长于0. 5至1秒）。</li><li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行 GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li></ul><h3 id="分区region-化整为零"><a href="#分区region-化整为零" class="headerlink" title="分区region,化整为零"></a>分区region,化整为零</h3><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB， 2MB， 4MB， 8MB， 1 6MB，<br>32MB。可以通过一 XX：G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。<br>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region （不需要连续）的集合。通过Region的动态分配方式实现逻辑_上的连续。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051423458.png" alt="image-20210706162729369"></p><p>一个region 有可能属于Eden， Survivor 或者0ld&#x2F;Tenured<br>内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，0表示属于0ld内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H。</p><p>设置H的原因：</p><ul><li></li></ul><p>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full<br>GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><h3 id="G1回收器垃圾回收过程"><a href="#G1回收器垃圾回收过程" class="headerlink" title="G1回收器垃圾回收过程"></a>G1回收器垃圾回收过程</h3><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p><ul><li><p>年轻代GC （Young GC ）</p></li><li><p>老年代并发标记过程（ Concurrent Marking）</p></li><li><p>混合回收（Mixed GC ）</p></li><li><p>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p></li><li><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051423041.png" alt="image-20210706162819150"></p></li><li><p>应用程序分配内存，&#x3D;&#x3D;当年轻代的Eden区用尽时开始年轻代回收过程&#x3D;&#x3D;； G1的年轻代收集阶段是一个并行的&#x3D;&#x3D;独占式&#x3D;&#x3D;收集器。在年轻代回收期，G1<br>GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p></li><li><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</p></li><li><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1<br>GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起<br>被回收的。</p></li><li><p>举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31<br>个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p></li></ul><h2 id="八-总结"><a href="#八-总结" class="headerlink" title="八 总结"></a>八 总结</h2><p>截止JDK 1.8，一共有7款不同的垃圾收集器。</p><h3 id="1-对比"><a href="#1-对比" class="headerlink" title="1.对比"></a>1.对比</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051423887.png" alt="image-20210706164337791"></p><h3 id="2-组合"><a href="#2-组合" class="headerlink" title="2.组合"></a>2.组合</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051423392.png" alt="image-20210706164353493"></p><h3 id="3-如何选择"><a href="#3-如何选择" class="headerlink" title="3.如何选择"></a>3.如何选择</h3><ul><li>&#x3D;&#x3D;1.优先调整堆的大小让JVM自适应完成。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;2.如果内存小于100M，使用串行收集器&#x3D;&#x3D;</li><li>&#x3D;&#x3D;3.如果是单核、单机程序，并且没有停顿时间的要求，串行收集器&#x3D;&#x3D;</li><li>&#x3D;&#x3D;4.如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择&#x3D;&#x3D;</li><li>&#x3D;&#x3D;5.如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器&#x3D;&#x3D;</li><li>&#x3D;&#x3D;官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。&#x3D;&#x3D;</li></ul><h3 id="最后需要明确个观点："><a href="#最后需要明确个观点：" class="headerlink" title="最后需要明确个观点："></a>最后需要明确个观点：</h3><ul><li>1.没有最好的收集器，更没有万能的收集；</li><li>2.调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul><h2 id="九-GC日志分析"><a href="#九-GC日志分析" class="headerlink" title="九 GC日志分析"></a>九 GC日志分析</h2><p>通过阅读GC日志，我们可以了解Java虛拟机内存分配与回收策略。内存分配与垃圾回收的参数列表</p><ul><li><h4 id="XX-PrintGC-输出GC日志。-显示总的GC堆的变化"><a href="#XX-PrintGC-输出GC日志。-显示总的GC堆的变化" class="headerlink" title="-XX:+PrintGC 输出GC日志。 显示总的GC堆的变化"></a>-XX:+PrintGC 输出GC日志。 显示总的GC堆的变化</h4><ul><li><p>打开GC日志：-verbose:gc</p></li><li><p>这个只会显示总的GC堆的变化， 如下：</p></li><li><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC （Allocation Failure） 80832K一&gt;19298K（227840K），<span class="number">0.0084018</span> secs]</span><br><span class="line">[GC （Metadata GC Threshold） 109499K一&gt;21465K （228352K），<span class="number">0.0184066</span> secs]</span><br><span class="line">[Full GC （Metadata GC Threshold） <span class="number">21</span> 465K一&gt;16716K （201728K），<span class="number">0.0619261</span> secs ]</span><br></pre></td></tr></table></figure></li><li><p>解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GC、Full GC： GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代， 老年代。</span><br><span class="line">Allocation Failure： GC发生的原因。</span><br><span class="line">80832K一&gt; 19298K：堆在GC前的大小和GC后的大小。</span><br><span class="line">228840k：现在的堆大小。</span><br><span class="line"><span class="number">0.0084018</span> secs： GC持续的时间。</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="XX：-PrintGCDetails-输出GC的详细日志"><a href="#XX：-PrintGCDetails-输出GC的详细日志" class="headerlink" title="-XX： +PrintGCDetails 输出GC的详细日志"></a>-XX： +PrintGCDetails 输出GC的详细日志</h4><ul><li>输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC （Allocation Failure） [ PSYoungGen： 70640K一&gt; 10116K（141312K） ] 80541K一&gt;20017K （227328K），<span class="number">0.0172573</span> secs] [Times： user=<span class="number">0.03</span> sys=<span class="number">0.00</span>， real=<span class="number">0.02</span> secs ]</span><br><span class="line">[GC （Metadata GC Threshold） [PSYoungGen：98859K一&gt;8154K（142336K） ] 108760K一&gt;21261K （228352K），</span><br><span class="line"><span class="number">0.0151573</span> secs] [Times： user=<span class="number">0.00</span> sys=<span class="number">0.01</span>， real=<span class="number">0.02</span> secs]</span><br><span class="line">[Full GC （Metadata GC Threshold） [PSYoungGen： 8154K一&gt;0K（142336K） ] [ParOldGen： 13107K一&gt;16809K（62464K） ] 21261K一&gt;16809K （204800K），[Metaspace： 20599K一&gt;20599K （1067008K） ]，<span class="number">0.0639732</span> secs]</span><br><span class="line">[Times： user=<span class="number">0.14</span> sys=<span class="number">0.00</span>， real=<span class="number">0.06</span> secs]</span><br></pre></td></tr></table></figure><ul><li>解析：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化</span><br><span class="line">ParOldGen：使用了Parallel Old并行垃圾收集器的老年代Gc前后大小的变化</span><br><span class="line">Metaspace： 元数据区GC前后大小的变化，JDK1<span class="number">.8</span>中引入了 元数据区以替代永久代</span><br><span class="line">xxx secs ： 指Gc花费的时间</span><br><span class="line">Times： user： 指的是垃圾收集器花费的所有CPU时间，sys： 花费在等待系统调用或系统事件的时间， real ：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</span><br></pre></td></tr></table></figure></li><li><h4 id="XX：-PrintGCTimeStamps-输出GC的时间戳（以基准时间的形式）"><a href="#XX：-PrintGCTimeStamps-输出GC的时间戳（以基准时间的形式）" class="headerlink" title="-XX： +PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）"></a>-XX： +PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</h4><ul><li>打开GC日志： <code>一verbose：gc 一XX： +PrintGCDetails 一XX：+PrintGCTimeStamps 一 XX： +PrintGCDateStamps</code></li><li>输入信息如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>一09一24T22：<span class="number">15</span>：<span class="number">24.518</span>+0800：<span class="number">3.287</span>： [GC（Allocation Failure） [ PSYoungGen： <span class="number">1361</span> 62K一&gt;5113K（136192K） ] 141425K一&gt;17632K （222208K） ，<span class="number">0.0248249</span> secs] [Times： user=<span class="number">0.</span>05sys=<span class="number">0.00</span>， real=<span class="number">0.03</span> secs ]</span><br><span class="line"><span class="number">2019</span>一09一24T22：<span class="number">15</span>：<span class="number">25.559</span>+0800：<span class="number">4.329</span>： [ GC（Metadata GC Threshold）[PSYoungGen：97578K一&gt;10068K（274944K） ] 110096K一&gt;22658K （360960K），<span class="number">0.0094071</span> secs]</span><br><span class="line">[Times： user=<span class="number">0.</span> 00sys=<span class="number">0.00</span>， real=<span class="number">0.</span> <span class="number">01</span> secs]</span><br><span class="line"><span class="number">2019</span>一09一24T22：<span class="number">15</span>：<span class="number">25.569</span>+0800：<span class="number">4.338</span>： [Full GC （Metadata GC Threshold）[ PSYoungGen：10068K一&gt;0K（274944K） ] [ ParoldGen： 12590K一&gt;13564K （56320K） ] 22658K一&gt;13564K （331264K） ，</span><br><span class="line">[Metaspace： 20590K一&gt;20590K（1067008K）]， <span class="number">0.</span> 0494875 secs]</span><br><span class="line">[Times： user=<span class="number">0.17</span> sys=<span class="number">0.</span> <span class="number">02</span>，real=<span class="number">0.05</span> secs ]     </span><br></pre></td></tr></table></figure></li><li><h4 id="XX：-PrintGCDateStamps输出GC的时间戳（以日期的形式，如2013一05一04T21-：-53：59-234-0800-）"><a href="#XX：-PrintGCDateStamps输出GC的时间戳（以日期的形式，如2013一05一04T21-：-53：59-234-0800-）" class="headerlink" title="-XX： +PrintGCDateStamps输出GC的时间戳（以日期的形式，如2013一05一04T21 ： 53：59.234+0800 ）"></a>-XX： +PrintGCDateStamps输出GC的时间戳（以日期的形式，如2013一05一04T21 ： 53：59.234+0800 ）</h4></li><li><h4 id="XX：-PrintHeapAtGC-在进行GC的前后打印出堆的信息"><a href="#XX：-PrintHeapAtGC-在进行GC的前后打印出堆的信息" class="headerlink" title="-XX： +PrintHeapAtGC 在进行GC的前后打印出堆的信息"></a>-XX： +PrintHeapAtGC 在进行GC的前后打印出堆的信息</h4></li><li><h4 id="Xloggc：-x2F-logs-x2F-gc-log日志文件的输出路径"><a href="#Xloggc：-x2F-logs-x2F-gc-log日志文件的输出路径" class="headerlink" title="-Xloggc：. . &#x2F;logs&#x2F;gc. log日志文件的输出路径"></a>-Xloggc：. . &#x2F;logs&#x2F;gc. log日志文件的输出路径</h4></li></ul><h3 id="日志分析工具使用"><a href="#日志分析工具使用" class="headerlink" title="日志分析工具使用"></a>日志分析工具使用</h3><p>可以用一些工具去分析这些gc日志。<br>常用的日志分析.工具有： GCViewer、GCEasy、GCHisto、GCLogViewer 、Hpjmeter、garbagecat等。</p><h2 id="X-垃圾回收器的新发展"><a href="#X-垃圾回收器的新发展" class="headerlink" title="X 垃圾回收器的新发展"></a>X 垃圾回收器的新发展</h2><p>GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK 10以后，Fu1l<br>GC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。<br>即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在Serverless等新的应用场景下，Serial<br>GC找到了新的舞台。<br>比较不幸的是CMS GC， 因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。</p><h3 id="JDK11-新特性"><a href="#JDK11-新特性" class="headerlink" title="JDK11 新特性"></a>JDK11 新特性</h3><ul><li>JEP318 : Epsilon: A No一Op Garbage Collector (Epsilon 垃圾回收器,”No一Op (无操作) “回收器) http: &#x2F; &#x2F;openidk.java.net&#x2F;ieps&#x2F;318</li><li>JEP333: ZGC: A Scalable Low一 Latency ;Garbage Collector (Experimental) ( ZGC:可伸縮的低延退竝坂回收器，处于试验性阶段)</li></ul><h3 id="Open-JDK12的Shenandoah-GC"><a href="#Open-JDK12的Shenandoah-GC" class="headerlink" title="Open JDK12的Shenandoah GC"></a>Open JDK12的Shenandoah GC</h3><ul><li>现在G1回收器已成为默认回收器好几年了。</li><li>我们还看到了引入了两个新的收集器： ZGC （ JDK11出现）和Shenandoah（Open JDK12） 。<ul><li>➢主打特点：低停顿时间</li></ul></li></ul><p><strong>Open JDK12 的Shenandoah GC：低停顿时间的GC （实验性）</strong></p><ul><li></li></ul><p>Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的HotSpot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p><ul><li>Shenandoah垃圾回收器最初由RedHat进行的一项垃 圾收集器研究项目PauselessGC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</li><li>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃<br>圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</li><li><img src="https://user-gold-cdn.xitu.io/2020/6/28/172f8949968d9d3e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="28"></li><li>这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看：<ul><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ul></li><li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC的强项：低延迟时间。</li></ul><h3 id="革命性的ZGC"><a href="#革命性的ZGC" class="headerlink" title="革命性的ZGC"></a>革命性的ZGC</h3><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning/z-garbage-collector1.html">官网链接</a><br>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。<br>《深入理解Java虚拟机》一书中这样定义ZGC： ZGC收集器是一款基于Region内存布局的，（暂时） 不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记一压缩算法的，以低延迟为首要目标的一款垃圾收集器。<br>ZGC的工作过程可以分为4个阶段：并发标记一并发预备重分配一并发重分配一并发重映射等。<br>ZGC几乎在所有地方并发执行的，除了初始标记的是sTW的。所以停顿时间.几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、958停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在10毫秒以内。</p><h3 id="JDK14新特性"><a href="#JDK14新特性" class="headerlink" title="JDK14新特性"></a>JDK14新特性</h3><p><strong>JEP 364： ZGC应用在macOS上</strong><br><strong>JEP 365： ZGC应用在windows上</strong> JDK14之前，ZGC仅Linux才支持</p><ul><li>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS 上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOs.上。</li><li>现在mac或Windows 上也能使用zGC了，示例如下： 一XX： +Unloc kExperimentalVMOptions 一XX： +UseZGC .</li></ul><h3 id="其他垃圾回收器-AliGC"><a href="#其他垃圾回收器-AliGC" class="headerlink" title="其他垃圾回收器:AliGC"></a>其他垃圾回收器:AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面 向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p>当然，其他厂商也提供了各种独具一格的GC实现，例如比较有名的低延迟GC</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-垃圾回收概述</title>
      <link href="/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"/>
      <url>/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420337.jpg"></p><h2 id="一、什么是垃圾"><a href="#一、什么是垃圾" class="headerlink" title="一、什么是垃圾"></a>一、什么是垃圾</h2><p>什么是垃圾（ Garbage） 呢？</p><p>➢垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。<br>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空 间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p><ul><li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li><li>关于垃圾收集有三个经典问题：<ul><li>➢哪些内存需要回收？</li><li>➢什么时候回收？</li><li>➢如何回收？</li></ul></li><li></li></ul><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><h2 id="二、为什么需要GC"><a href="#二、为什么需要GC" class="headerlink" title="二、为什么需要GC"></a>二、为什么需要GC</h2><ul><li><p>对于高级语言来说，一个基本认知是，如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p></li><li><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM 将整理出的内存分配给新的对象。</p></li><li><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p></li></ul><h2 id="三、早期的垃圾回收"><a href="#三、早期的垃圾回收" class="headerlink" title="三、早期的垃圾回收"></a>三、早期的垃圾回收</h2><ul><li>在早期的C&#x2F;C++时代，垃圾回收基本.上是手工进行的。开发人员可以使用</li></ul><p>new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>()；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span> （pBridge-&gt;Register（kDestroy）！= NO_ERROR）</span><br><span class="line"><span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure><ul><li></li></ul><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来&#x3D;&#x3D;频繁申请和释放内存的管理负担&#x3D;&#x3D;。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p><ul><li>在有了垃圾回收机制后，上述代码块极有可能变成这样：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>()；</span><br><span class="line">pBridge -&gt; <span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure><ul><li>现在，除了Java以外，C#、Python、 Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</li></ul><h2 id="四、Java垃圾回收机制"><a href="#四、Java垃圾回收机制" class="headerlink" title="四、Java垃圾回收机制"></a>四、Java垃圾回收机制</h2><ul><li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p></li><li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p></li><li><p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p></li><li><p>此时，了 解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时， 快速地根据错误异常日志定位问题和解决问题。</p></li><li><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p></li><li><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。</p><ul><li>其中，Java堆是垃圾收集器的工作重点。</li><li>从次数上讲：<ul><li>频繁收集Young区</li><li>较少收集0ld区</li><li>基本不动Perm区(方法区)</li></ul></li></ul></li><li><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420617.png" alt="image-20210703093933143"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-垃圾回收相关算法</title>
      <link href="/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
      <url>/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="一、判断阶段：对象存活判断"><a href="#一、判断阶段：对象存活判断" class="headerlink" title="一、判断阶段：对象存活判断"></a>一、判断阶段：对象存活判断</h2><ul><li></li></ul><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><ul><li><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p></li><li><p>判断对象存活一般有两种方式：&#x3D;&#x3D;引用计数算法&#x3D;&#x3D;和&#x3D;&#x3D;可达性分析算法&#x3D;&#x3D;。</p></li></ul><h3 id="1、引用计数算法"><a href="#1、引用计数算法" class="headerlink" title="1、引用计数算法"></a>1、引用计数算法</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><ul><li><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型 的引用计数器属性。用于记录对象被引用的情况。</p></li><li><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p></li></ul><h4 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h4><ul><li>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li></ul><h4 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a>1.3 缺点</h4><ul><li><p>需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</p></li><li><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</p></li><li><p>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一 条致命缺陷，导致&#x3D;&#x3D;在Java的垃圾回收器中没有使用这类算法&#x3D;&#x3D;。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420565.png" alt="image-20210703094326043"></p></li></ul><h4 id="1-4-代码测试Java中没有使用引用计数算法"><a href="#1-4-代码测试Java中没有使用引用计数算法" class="headerlink" title="1.4 代码测试Java中没有使用引用计数算法"></a>1.4 代码测试Java中没有使用引用计数算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码测试Java中没有使用引用计数算法来判断对象是否为垃圾</span></span><br><span class="line"><span class="comment"> * VM参数：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//故意占用空间10M</span></span><br><span class="line">    <span class="type">byte</span> data[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">refCountGC1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">refCountGC2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环引用</span></span><br><span class="line">        refCountGC1.ref = refCountGC2;</span><br><span class="line">        refCountGC2.ref = refCountGC1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取消外界对其的引用</span></span><br><span class="line">        refCountGC1 = <span class="literal">null</span>;</span><br><span class="line">        refCountGC2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>手动GC关闭的时候，未执行GC，新生区占用used 25682K</li></ul><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210703101536496.png" alt="image-20210703101536496"></p><ul><li><p>手动执行GC打开，执行GC，新生区占用650K</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420567.png" alt="image-20210703101147058"></p></li></ul><p>说明执行GC之后，两个互相引用的对象被回收，也就是互相的循环依赖引用的两个对象会被判定为垃圾被清理，说明Java使用的不是引用计数算法。而是可达性分析算法。</p><h3 id="2、可达性分析算法-x2F-追踪性垃圾收集"><a href="#2、可达性分析算法-x2F-追踪性垃圾收集" class="headerlink" title="2、可达性分析算法&#x2F;追踪性垃圾收集"></a>2、可达性分析算法&#x2F;追踪性垃圾收集</h3><ul><li><p>相对于引用计数而言，可达性分析算法解决了循环引用的问题。防止了内存泄露的发生。</p></li><li><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul><li><p>可达性分析算法是以根对象（GCRoots）为起始点，按照从上至下的方式&#x3D;&#x3D;搜索被根对象集合所连接的目标对象是否可达。&#x3D;&#x3D;</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420681.png" alt="image-20210703102423042"></p></li><li><p>使用可达性分析算法之后，内存中存活的对象都会被根对象集合直接或者间接连接，搜索走过的路径叫做&#x3D;&#x3D;引用链&#x3D;&#x3D;。</p></li><li><p>如果目标对象没有任何引用链相连，则表示不可达，为垃圾。</p></li></ul></li><li><h4 id="Java语言中，GCRoots链包括以下几类元素"><a href="#Java语言中，GCRoots链包括以下几类元素" class="headerlink" title="Java语言中，GCRoots链包括以下几类元素"></a>Java语言中，GCRoots链包括以下几类元素</h4><ul><li>各个线程被调用的方法中的参数，&#x3D;&#x3D;局部变量&#x3D;&#x3D;</li><li>本地方法栈内JNT（本地方法）引用的对象</li><li>方法区中&#x3D;&#x3D;静态属性&#x3D;&#x3D;引用的对象<ul><li>比如： Java类中引用类型静态变量</li></ul></li><li>方法区中的&#x3D;&#x3D;常量引用的对象&#x3D;&#x3D;<ul><li>比如字符串常量池的引用</li></ul></li><li>所有&#x3D;&#x3D;被同步锁持有的对象&#x3D;&#x3D;</li><li>虚拟机的内部引用<ul><li>基本数据类型的包装类，常驻的异常对象，系统类加载器</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li><li>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（Partial GC）。</li><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针 对新生代），<br>必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，<br>这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一.并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li></ul></li><li><p>小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421199.png" alt="image-20210703205542925"></p><p><strong>注意</strong></p><ul><li><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p></li><li><p>这点也是导致GC进行时必须“StopTheWorld”的一个重要原因。</p><ul><li>➢即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li></ul></li></ul></li></ul><h2 id="二、对象的finalization机制"><a href="#二、对象的finalization机制" class="headerlink" title="二、对象的finalization机制"></a>二、对象的finalization机制</h2><ul><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize（）方法。</li><li>finalize（）方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li><li>永远不要主动调用某个对象的finalize （）方法，应该交给垃圾回收机制调用。理由包括下面三点：<ul><li>➢在finalize()时可能会导致对象复活。</li><li>➢finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li>➢一个糟糕的finalize （）会严重影响GC的性能。</li></ul></li><li>从功能上来说，finalize（）方法与C++ 中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质，上不同于C++ 中的析构函数。</li></ul><h3 id="1-对象是否”死亡"><a href="#1-对象是否”死亡" class="headerlink" title="1.对象是否”死亡"></a>1.对象是否”死亡</h3><ul><li>由于finalize （）方法的存在，&#x3D;&#x3D;虚拟机中的对象一般处于三种可能的状态。&#x3D;&#x3D;</li><li></li></ul><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。&#x3D;&#x3D;一个无法触及的对象有可能在某一个条件下“复活”自己&#x3D;&#x3D;，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li><p>➢&#x3D;&#x3D;可触及的&#x3D;&#x3D;：从根节点开始，可以到达这个对象。</p></li><li><p>➢&#x3D;&#x3D;可复活的&#x3D;&#x3D;：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</p></li><li><p>➢&#x3D;&#x3D;不可触及的&#x3D;&#x3D;：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize（） 只会被调用一一次。</p></li><li><p>以上3种状态中，是由于finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p></li></ul><h3 id="2-判定是否可以回收具体过程"><a href="#2-判定是否可以回收具体过程" class="headerlink" title="2.判定是否可以回收具体过程"></a>2.<strong>判定是否可以回收具体过程</strong></h3><p>如果对象objA到GC Roots没有引用链，则进行第一 次标记。</p><p>进行筛选，判断此对象是否有必要执行finalize（）方法</p><ol><li>①如果对 象objA没有重写finalize（）方法，或者finalize （）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>②如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F一Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li></li></ol><p>③finalize（）方法是对象逃脱死亡的最后机会，稍后Gc会对F一Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。<br>在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</p><h3 id="3-代码测试对象复活"><a href="#3-代码测试对象复活" class="headerlink" title="3.代码测试对象复活"></a>3.代码测试对象复活</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObject ref;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        <span class="comment">//当前待回收的对象重新加入引用链</span></span><br><span class="line">        ref = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ref = <span class="keyword">new</span> <span class="title class_">CanReliveObject</span>();</span><br><span class="line"></span><br><span class="line">        ref = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//调用垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次GC执行完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为finalize优先级较低 主线程暂停2s 等待它</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象已死&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象未死&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ref = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次GC执行完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象已死&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象未死&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用对象ref刚开始指向一个对象，&#x3D;&#x3D;此时为可触及状态&#x3D;&#x3D;然后让他指向null，&#x3D;&#x3D;此时为可复活状态&#x3D;&#x3D;手动调用GC，此时处于会回调执行重写的finalize方法，方法中给这个引用重新赋值了，所以此时为&#x3D;&#x3D;可触及状态&#x3D;&#x3D;</p><p>再次指向NULL，此时为&#x3D;&#x3D;不可触及状态&#x3D;&#x3D;（finalize方法只执一次），所以对象此时已经死了。</p><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一次GC执行完毕</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">对象未死</span><br><span class="line">第二次GC执行完毕</span><br><span class="line">对象已死</span><br></pre></td></tr></table></figure><h2 id="三、MAT与JProfiler的GCRoots溯源"><a href="#三、MAT与JProfiler的GCRoots溯源" class="headerlink" title="三、MAT与JProfiler的GCRoots溯源"></a>三、MAT与JProfiler的GCRoots溯源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Jprofiler打开程序</p><p>点击左侧<img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421189.png" alt="image-20210704131301662"></p><p>选择<img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421856.png" alt="image-20210704131312462"></p><p>选择一个元素 点击<img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421300.png" alt="image-20210704131341325"></p><p>即可显示该元素的GCGoots链</p><h3 id="MAT查看略。"><a href="#MAT查看略。" class="headerlink" title="MAT查看略。"></a>MAT查看略。</h3><h3 id="使用Jprofiler查看OOM"><a href="#使用Jprofiler查看OOM" class="headerlink" title="使用Jprofiler查看OOM"></a>使用Jprofiler查看OOM</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xms8m -Xmx8m -XX:+HeopDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//占1M</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个HeapOOM对象中有一个10M的bytes数组。循环创建 直到堆OOM</p><p>运行代码 生成dump文件。用Jprofiler打开 发现</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421490.png" alt="image-20210704132433192"></p><p>确实有一个arrayList对象占用超过90%</p><h2 id="四、清除阶段"><a href="#四、清除阶段" class="headerlink" title="四、清除阶段"></a>四、清除阶段</h2><blockquote><p>当成功区分出内存中存活对象和死亡对象之后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的空间。目前比较常用的算法有三种</p><ul><li>标记清除算法</li><li>复制算法</li><li>标记压缩算法</li></ul></blockquote><h3 id="1、标记清除算法（Mark-Sweep）"><a href="#1、标记清除算法（Mark-Sweep）" class="headerlink" title="1、标记清除算法（Mark-Sweep）"></a>1、标记清除算法（Mark-Sweep）</h3><ul><li><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>标记清除算法是一种非常基础和常见的垃圾收集算法</li></ul></li><li><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><ul><li><p>当堆中的有效内存空间被耗尽时，就会停止程序STW，然后进行标记-清除</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421647.png" alt="image-20210704133431320"></p><ul><li>标记：Collector从引用的根节点开始遍历，标记所有的被引用的对象，在对象的对象头中记录为可达对象</li><li>清除：将对象头中没有标记为可达对象的对象进行清除</li></ul></li></ul></li><li><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>常用，简单</li></ul></li><li><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>➢效率不算高(两次O（n）)</li><li>➢在进行GC的时候，需要停止整个应用程序，导致用户体验差</li><li>➢这种方式清理出来的&#x3D;&#x3D;空闲内存是不连续的，产生内存碎片&#x3D;&#x3D;。需要维护一个空闲列表</li></ul></li><li><h4 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a><strong>何为清除？</strong></h4><ul><li><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲</p><p>的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</p></li></ul></li></ul><h3 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h3><ul><li><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>​ 为了解决标记清除算法效率方面的问题，M.L.Minsky于1963年发表了著名的论文，“ 使用双存储区的Li sp语言垃圾收集器CALISP Garbage Collector Algorithm Using<br>SerialSecondary Storage ）”。M.L. Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M. L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p></li><li><p>核心思想</p><p>​ 将活着的内存空间分为两块，每次使用一块，进行垃圾回收的时候，将存活对象复制到另一块未使用的区域，然后将源区域清空，然后交换两个内存的角色</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421468.png" alt="image-20210704134558378"></p></li><li><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li>没有标记和清除过程，实现简单，&#x3D;&#x3D;运行高效&#x3D;&#x3D;</li><li>复制过去以后保证&#x3D;&#x3D;空间连续性&#x3D;&#x3D;，不会出现“碎片”问题。</li></ul></li><li><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p>此算法的缺点也是很明显的，就是需要两倍的内存空间。</p></li><li><p>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</p></li><li><p><strong>特别的</strong> 如果系统中的可用对象很多，复制算法不会很理想，因为要复制大量的对象</p></li></ul><p>在新生代，对常规应用的垃圾回收，一次通常可以回收708一 99的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p></li></ul><h3 id="3、标记压缩算法"><a href="#3、标记压缩算法" class="headerlink" title="3、标记压缩算法"></a>3、标记压缩算法</h3><ul><li><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。<br>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。&#x3D;&#x3D;标记一压缩（Mark一Compact） 算法由此诞生&#x3D;&#x3D;。<br>1970年前后，G. L. Steele 、C. J. Chene和D.S. Wise 等研究者发布标记一压缩算法。在许多现代的垃圾收集器中，人们都使用了标记一压缩算法或其改进版本。</li></ul><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><ul><li>第一阶段和标记一清除算法一样，从根节点开始标记所有被引用对象.</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li><li>之后，清理边界外所有的空间。</li></ul><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421544.png" alt="image-20210704140307884"></p><ul><li><p>标记一压缩算法的最终效果等同于标记一清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记一清除一压缩（Mark一 Sweep一Compact）算法。</p></li><li><p>二者的本质差异在于&#x3D;&#x3D;标记清除算法是一种非移动式&#x3D;&#x3D;的回收算法，&#x3D;&#x3D;标记压.缩是移动式&#x3D;&#x3D;的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p></li><li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p></li><li><h4 id="指针碰撞（Bump-the-Pointer-）"><a href="#指针碰撞（Bump-the-Pointer-）" class="headerlink" title="指针碰撞（Bump the Pointer ）"></a>指针碰撞（Bump the Pointer ）</h4></li></ul><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump<br>the Pointer） 。</p><ul><li><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了标记一清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只 需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul></li><li><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率.上来说，标记一整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li><li>移动过程中，需要全程暂停用户应用程序。即： STW</li></ul></li><li><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>| 属性\算法  | 标记清除算法 | 复制算法 | 标记压缩算法 |<br>  | ———- | ———— | ——– | ———— |<br>| 时间复杂度 | 中           | 快       | 满           |<br>| 空间复杂度 | 少           | 占用2倍  | 少           |<br>| 内存碎片   | 有           | 无       | 无           |<br>| 移动对象   | 否           | 是       | 是           |</p></li></ul><h3 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，</p><p>它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。</p><p>因此，&#x3D;&#x3D;不同生命周期的对象可以采取不同的收集方式，以便提高回收效率&#x3D;&#x3D;。</p><p>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，</p><p>以提高垃圾回收的效率。</p><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，</p><ul><li>比如Http请求中的Session对象、线程、Socket连接， 这类对象跟业务直接挂钩，因此生命周期比较长</li><li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如： String对象， 由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul><p>目前几乎所有的GC都是采用分代收集（Generational Collecting） 算法执行垃圾回收的。</p><p>​ 在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）<ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况&#x3D;&#x3D;复制算法&#x3D;&#x3D;的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。·</li></ul></li><li>老年代（Tenured Gen）<ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记整理的混合实现。<ul><li>➢标记阶段的开销与存活对象的数量成正比。</li><li>➢清除阶段的开销与所管理区域的大小成正相关。</li><li>➢压缩阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li></ul><p>以HotSpot中的CMS回收器为例，CMS是基于标记清除实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于标记压缩算法的Serialold回收器作为补偿措施：当内存回收不佳（碎片导致的执行失败时），将采用Serial<br>0ld执行Full GC（标记整理算法）以达到对老年代内存的整理。<br>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p><h3 id="5、增量收集算法"><a href="#5、增量收集算法" class="headerlink" title="5、增量收集算法"></a>5、增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在Stop the<br>World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental<br>Collecting） 算法的诞生。</p><ul><li><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5></li></ul><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。<br>总的来说，增量收集算法的基础仍是传统的标记清除和复制算法。增量收集算法<strong>通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong>。</p><ul><li><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5></li></ul><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h3 id="6、分区算法"><a href="#6、分区算法" class="headerlink" title="6、分区算法"></a>6、分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块<br>大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。<br>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。<br>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。<br><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421635.png" alt="16"></p><h2 id="五、关于Hotspot中垃圾回收相关算法的实现细节"><a href="#五、关于Hotspot中垃圾回收相关算法的实现细节" class="headerlink" title="五、关于Hotspot中垃圾回收相关算法的实现细节"></a>五、关于Hotspot中垃圾回收相关算法的实现细节</h2><p>​ 对于常见的对象存活判定和垃圾收集算法，Java虚拟机在实现时，必须对算法的执行效率有严格的考量，才能保证虚拟机的高效运行。我们以HotSpot虚拟机为例，来了解一下虚拟机对这些算法的优化。</p><ol><li><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>​ 以可达性分析算法中从GCRoots集合找引用链的这个操作为例来介绍虚拟机的高效实现。</p><p>​ 首先，我们知道，固定可作为GCRoots的节点主要包括<code>全局性引用</code>（常量或者静态属性）以及<code>执行上下文</code><br>（栈帧中的局部变量，参数等）中，尽管定义非常明确，但是查找过程中要做到高效并非一件容易的事情，并且现在Java应用越来越大，光是方法区的大小就数百M，里边的类更多，如果虚拟机真的逐个检查每个引用是否能作为GCRoots，需要耗费大量的时间。</p><p>​ 迄今为止，所有的垃圾回收器在进行GCRoots<code>根节点枚举的</code>时候，都必须<code>暂停用户线程</code><br>，虽然最耗时的查找引用链以及可以做到和用户线程并发了，但是在根节点枚举的时候，还是必须在一个能保障一致性快照中才可以进行。如果在枚举过程中发生了变化，分析的结果准确性就无法保证。因此，号称是停顿时间可控，或者几乎不会发生停顿的CMS，G1，ZGC等回收器在根节点枚举的时候也是必须停顿的。</p><p>​ 因此，我们感觉，应该可以让虚拟机从某些地方直接得到存放对象的引用的。HotSpot的解决方案是，使用一组称为<code>OopMap</code>的数据结构来达到这个目的。具体做法如下</p><p>​ 一旦类加载动作完成的时候，HotSpot就会把对象内多少偏移量上是什么类型的数据计算出来，在即时编译的时候，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样收集器在扫描的时候就可以直接知道这些信息了。<br>并不需要一个不漏的从方法区等 GCRoots开始查找。</p></li><li><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>​ 在上述中<code>OopMap</code>的协助下，HotSpot可以很快的完成GCRoots枚举，但是一个很现实的问题来了，导致OopMap内容变化的指令非常多，如果为每一指令都生成对应的<code>OopMap</code>，那么将会需要大量的额外存储空间。</p><p>​ 实际上虚拟机只会在<code>一些特定的位置</code>生成<code>OopMap</code>，这些位置被称为<code>安全点</code>。只有代码执行到安全点的时候，才可以停下来进行垃圾回收。</p><p>​ 安全点的选定不能太少以至于让收集器等待时间过长，也不能太多以至于占用运行时的内存负荷。一些比较有代表性的安全点比如：方法调用、循环跳转、异常跳转等地方。</p><p>​ 对于一个安全点另外一个需要考虑的问题是，如果让垃圾回收发生时所有的线程都在安全点停下来。主要有两种选择。</p><ul><li>抢先式中断</li></ul><p>在垃圾回收发生时，系统将所有的用户线程全部中断，如果发现某条线程不在安全点，则恢复执行，直到所有的线程都到达安全点。（几乎没有虚拟机这么做）</p><ul><li><p>主动式中断</p><p>在垃圾回收发生的时候，会将一个标志位设置为真。每个线程在执行的时候都会不断的主动去轮询这个标志位，如果为真，则在最近的安全点挂起。</p></li></ul><ol start="3"><li><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>​<br>使用安全点的设计似乎已经完美解决了如果停顿用户线程。但是，在程序不执行的时候，也就是线程阻塞时，线程无法响应虚拟机的中断请求。不能主动走到安全点挂起自己，虚拟机也不太可能持续等待到线程重新激活然后分配处理器时间，对于这种情况，必须引入安全区域来解决。</p><p>​ 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域内开始垃圾收集都是安全的。我们可以把安全区域看成被扩展的安全点。</p><p>​<br>当用户线程执行到安全区域中时，首先会标识自己已经进入了安全区域，那么当这段时间内虚拟机需要发起垃圾收集的时候就不必管这些已经声明自己在安全区域内的线程。当线程要离开安全区域时，他会检查虚拟机是否已经完成了根节点枚举。如果完成，线程会推出安全区域。否则一直等待，直到可以离开为止。</p></li></ol></li></ol><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-垃圾回收相关概念</title>
      <link href="/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="一-System-gc的理解"><a href="#一-System-gc的理解" class="headerlink" title="一. System.gc的理解"></a>一. System.gc的理解</h2><ul><li><p>在默认情况下，手动调用System.gc或者RunTime.getRunTime().gc()，会显式出发FullGC 同时对新生代和老年代进行回收，尝试释放垃圾。</p></li><li><p>然而System.gc（）调用附带一个免责声明，&#x3D;&#x3D;无法保证对垃圾收集器的调用(无法保证马上触发GC)&#x3D;&#x3D;。</p></li><li><p>JVM实现者可以通过system.gc（）调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc（）。</p></li><li><p>以下代码,如果注掉System.runFinalization(); 那么控制台不保证一定打印,证明了System.gc（）无法保证GC一定执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc </span></span><br><span class="line">        </span><br><span class="line">        System.runFinalization();<span class="comment">//强制调用失去引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手动gc理解不可达对象的回收行为"><a href="#手动gc理解不可达对象的回收行为" class="headerlink" title="手动gc理解不可达对象的回收行为"></a>手动gc理解不可达对象的回收行为</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//输出: 不会被回收, FullGC时被放入老年代</span></span><br><span class="line">        <span class="comment">//[GC (System.gc()) [PSYoungGen: 14174K-&gt;10736K(76288K)] 14174K-&gt;10788K(251392K), 0.0089741 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span></span><br><span class="line">        <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 52K-&gt;10649K(175104K)] 10788K-&gt;10649K(251392K), [Metaspace: 3253K-&gt;3253K(1056768K)], 0.0074098 secs] [Times: user=0.01 sys=0.02, real=0.01 secs]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//输出: 正常被回收</span></span><br><span class="line">        <span class="comment">//[GC (System.gc()) [PSYoungGen: 14174K-&gt;544K(76288K)] 14174K-&gt;552K(251392K), 0.0011742 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span></span><br><span class="line">        <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 544K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;410K(175104K)] 552K-&gt;410K(251392K), [Metaspace: 3277K-&gt;3277K(1056768K)], 0.0054702 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//输出: 不会被回收, FullGC时被放入老年代 局部变量表中索引为1的位置依然在 所以不会被回收</span></span><br><span class="line">        <span class="comment">//[GC (System.gc()) [PSYoungGen: 14174K-&gt;10736K(76288K)] 14174K-&gt;10784K(251392K), 0.0076032 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span></span><br><span class="line">        <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(76288K)] [ParOldGen: 48K-&gt;10649K(175104K)] 10784K-&gt;10649K(251392K), [Metaspace: 3252K-&gt;3252K(1056768K)], 0.0096328 secs] [Times: user=0.01 sys=0.01, real=0.01 secs]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//输出: 正常被回收 局部变量表中索引1的位置被value占用 </span></span><br><span class="line">        <span class="comment">//[GC (System.gc()) [PSYoungGen: 14174K-&gt;496K(76288K)] 14174K-&gt;504K(251392K), 0.0016517 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span></span><br><span class="line">        <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 496K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;410K(175104K)] 504K-&gt;410K(251392K), [Metaspace: 3279K-&gt;3279K(1056768K)], 0.0055183 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> &#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//输出: 正常被回收</span></span><br><span class="line">        <span class="comment">//[GC (System.gc()) [PSYoungGen: 14174K-&gt;10720K(76288K)] 14174K-&gt;10744K(251392K), 0.0121568 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</span></span><br><span class="line">        <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 10720K-&gt;0K(76288K)] [ParOldGen: 24K-&gt;10650K(175104K)] 10744K-&gt;10650K(251392K), [Metaspace: 3279K-&gt;3279K(1056768K)], 0.0101068 secs] [Times: user=0.01 sys=0.02, real=0.01 secs]</span></span><br><span class="line">        <span class="comment">//[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10650K-&gt;10650K(251392K), 0.0005717 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span></span><br><span class="line">        <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10650K-&gt;410K(175104K)] 10650K-&gt;410K(251392K), [Metaspace: 3279K-&gt;3279K(1056768K)], 0.0045963 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();</span><br><span class="line">        local.localvarGC5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="二-内存溢出与内存泄漏"><a href="#二-内存溢出与内存泄漏" class="headerlink" title="二. 内存溢出与内存泄漏"></a>二. 内存溢出与内存泄漏</h2><ul><li><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4></li></ul><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现O0M的情况。</p><p>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>javadoc中对OutOfMemoryError的解释是，&#x3D;&#x3D;没有空闲内存，并且垃圾收集器也无法提供更多内存&#x3D;&#x3D;。</p><ul><li><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ul><li>（1） Java虚拟机的堆内存设置不够。<br>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数一Xms、一Xmx来调整。</li><li>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）对于老版本的Oracle<br>JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致0OM问题。对应的异常信息，会标记出来和永久代相关： <code>&quot;java. lang. OutOfMemoryError： PermGen space&quot;。</code><br>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的00M有所改观，出现00M，异常信息则变成了：<code>“java. lang. OutOfMemoryError： Metaspace&quot;</code>。 直接内存不足，也会导致0OM。</li></ul></li><li><p>这里面隐含着一层意思是，在抛出0utOfMemoryError之 前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>➢例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</li><li>➢在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</li></ul></li><li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>➢比如，我们去分配一一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接拋出OutOfMemoryError</li></ul></li><li><h4 id="内存泄漏-Memory-Leak"><a href="#内存泄漏-Memory-Leak" class="headerlink" title="内存泄漏(Memory Leak)"></a>内存泄漏(Memory Leak)</h4></li><li><p>也称作“存储渗漏”。<code>严格来说</code>，&#x3D;&#x3D;只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏&#x3D;&#x3D;。</p></li><li><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致&#x3D;&#x3D;对象的生命周期变得很长甚至导致内存溢出0OM&#x3D;&#x3D;，也可以叫做<code>宽泛意义</code>上的“内存泄漏</p></li><li><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。</p></li><li><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p></li><li><p><strong>举例</strong></p><ul><li>1、单例模式<br>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li><li>2、一些提供close的资源未关闭导致内存泄漏 数据库连接（ dataSourse. getConnection（）），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</li></ul></li></ul><h2 id="三-STW"><a href="#三-STW" class="headerlink" title="三. STW"></a>三. STW</h2><p>Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。.</p><ul><li>➢可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。.<ul><li>分析工作必须在一个能确保一致性的快照 中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上V- - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li></ul></li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样， 所以我们需要减少STW的发生。</p><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p><p>哪怕是G1也不能完全避免Stop一the一world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用System.gc（）；会导致STW的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopTheWorldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        list.add(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (list.size() &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        System.gc();<span class="comment">//会触发full gc，进而会出现STW事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每秒打印时间信息</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WorkThread</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>();</span><br><span class="line">        <span class="type">PrintThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintThread</span>();</span><br><span class="line">        w.start();</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四-垃圾回收的并行与并发"><a href="#四-垃圾回收的并行与并发" class="headerlink" title="四. 垃圾回收的并行与并发"></a>四. 垃圾回收的并行与并发</h2><h4 id="并发-Concurrent"><a href="#并发-Concurrent" class="headerlink" title="并发(Concurrent)"></a>并发(Concurrent)</h4><ul><li>在操作系统中，是指一个时间段中有几个程序都处于己启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</li><li>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051421362.png" alt="image-20210704170519397"></p><h3 id="并行-Parallel"><a href="#并行-Parallel" class="headerlink" title="并行(Parallel)"></a>并行(Parallel)</h3><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。</p><p>其实&#x3D;&#x3D;决定并行的因素不是CPU的数量，而是CPU的核心数量&#x3D;&#x3D;，比如一个CPU多个核也可以 并行。</p><p>适合科学计算，后台处理等弱交互场景</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422454.png"></p><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><ul><li><p>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</p><ul><li>如ParNew、 Parallel Scavenge、 Parallel 0ld；</li></ul></li><li><p>串行（Serial）</p><ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422069.png" alt="image-20210704171216140"></p></li><li><p>并发（Concurrent） ：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。</p></li><li><ul><li>➢用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li></ul></li><li><p>➢如： CMS、G1</p></li><li><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051422864" alt="5"></p></li></ul><h2 id="五-安全点与安全区域"><a href="#五-安全点与安全区域" class="headerlink" title="五. 安全点与安全区域"></a>五. 安全点与安全区域</h2><h3 id="安全点-SafePoint"><a href="#安全点-SafePoint" class="headerlink" title="安全点(SafePoint)"></a>安全点(SafePoint)</h3><ul><li>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint） ”</li><li>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择些执行时间较长的指令作为Safe<br>Point， 如方法调用、循环跳转和异常跳转等。</li></ul><h3 id="如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？"><a href="#如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？" class="headerlink" title="如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？"></a><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></h3><ul><li>抢先式中断： （目前没有虚拟机采用） 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>主动式中断： 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ul><h3 id="安全区域-Safe-Region"><a href="#安全区域-Safe-Region" class="headerlink" title="安全区域(Safe Region)"></a>安全区域(Safe Region)</h3><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”<br>到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。<br>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region 看做是被扩展了的Safepoint。</p><h3 id="实际执行时"><a href="#实际执行时" class="headerlink" title="实际执行时:"></a><strong>实际执行时:</strong></h3><ul><li>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会 忽略标识为Safe Region状态 的线程；</li><li>2、当线程即将离开Safe Region时， 会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开SafeRegion的信号为止；</li></ul><h2 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h2><table><thead><tr><th>引用</th><th>引用存在 是否回收</th><th>应用场景</th></tr></thead><tbody><tr><td>强引用</td><td>死也不回收</td><td>大部分</td></tr><tr><td>软引用</td><td>内存不足时回收</td><td>缓存</td></tr><tr><td>弱引用</td><td>GC即回收</td><td>缓存</td></tr><tr><td>虚引用</td><td></td><td>GC时对象跟踪</td></tr><tr><td>终结器引用</td><td></td><td></td></tr></tbody></table><h2 id="六-强引用（StrongReference）"><a href="#六-强引用（StrongReference）" class="headerlink" title="六. 强引用（StrongReference）"></a>六. 强引用（StrongReference）</h2><ul><li><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​ 最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，&#x3D;&#x3D;无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象&#x3D;&#x3D;。</p></li><li><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>​ 在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</li><li>当在Java语言中使用new操作符创建一个新的对象， 并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li><li>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</li><li>对于一一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li><li>相对的，软引用、 弱引用和虚引用的对象是软可触及、弱可触及和虛可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</li></ul></li></ul><h2 id="七-软引用（SoftReference）"><a href="#七-软引用（SoftReference）" class="headerlink" title="七. 软引用（SoftReference）"></a>七. 软引用（SoftReference）</h2><ul><li><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>​ 在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p></li><li><h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><ul><li>软引用是用来描述一 些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li><li>&#x3D;&#x3D;软引用通常用来实现内存敏感的缓存&#x3D;&#x3D;。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li><li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（ Reference Queue）。</li><li>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得.已才清理。</li><li>在JDK 1. 2版之后提供了java.lang.ref.SoftReference类来实现软引用。</li></ul></li><li><p>代码测试软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用的测试：内存不足即回收</span></span><br><span class="line"><span class="comment"> * -Xms10m -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象，建立软引用</span></span><br><span class="line"><span class="comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span></span><br><span class="line">        <span class="comment">//上面的一行代码，等价于如下的三行代码</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(u1);</span><br><span class="line">        u1 = <span class="literal">null</span>;<span class="comment">//取消强引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;GC之前软引用获取的对象&quot;</span> + userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;GC之后软引用获取的对象&quot;</span> + userSoftRef.get());<span class="comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让系统认为内存资源紧张、不够</span></span><br><span class="line"><span class="comment">//            byte[] b = new byte[1024 * 1024 * 7];</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">399</span> * <span class="number">1024</span>];<span class="comment">//恰好能放下数组又放不下u1的内存分配大小 不会报OOM</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;资源不足之后GC：软引用获取的对象&quot;</span> + userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="八-弱引用（WeakReference）"><a href="#八-弱引用（WeakReference）" class="headerlink" title="八. 弱引用（WeakReference）"></a>八. 弱引用（WeakReference）</h2><ul><li><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</p></li><li><h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><ul><li>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</li><li>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一 定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li><li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li><li>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。<ul><li>如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。</li><li>而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li></ul></li><li>在JDK1.2版之后提后了java.lang.ref.WeakReference类来实现弱引用</li><li>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</li></ul></li><li><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));</span><br><span class="line">        <span class="comment">//从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">//重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九-虚引用（PhantomReference）"><a href="#九-虚引用（PhantomReference）" class="headerlink" title="九. 虚引用（PhantomReference）"></a>九. 虚引用（PhantomReference）</h2><ul><li><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>一个对象是否有虛引用的存在，完全不会对其生存时 间构成影响，也无法通过虚引用来获得一个对象的实例。&#x3D;&#x3D;为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知(回收跟踪)&#x3D;&#x3D;。</p></li><li><h3 id="特征-3"><a href="#特征-3" class="headerlink" title="特征"></a>特征</h3><ul><li>虚引用(Phantom Reference),也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</li><li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li><li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get（）方法取得对象时，总是null。</li><li>&#x3D;&#x3D;为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程&#x3D;&#x3D;。比如：能在这个对象被收集器回收时收到一个系统通知。</li><li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li><li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录。</li><li>在JDK 1. 2版之后提供了PhantomReference类来实现虚引用。</li></ul></li><li><h3 id="代码测试-1"><a href="#代码测试-1" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line">调用当前类的finalize()方法</span><br><span class="line">obj 可用</span><br><span class="line">第 <span class="number">2</span> 次 gc</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="literal">null</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="X-终结器引用"><a href="#X-终结器引用" class="headerlink" title="X. 终结器引用"></a>X. 终结器引用</h2><ul><li><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><ul><li>它用以实现对象的finalize（）方法，也可以称为终结器引用。</li><li>无需手动编码， 其内部配合引用队列使用。</li><li>在GC时， 终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize（）方法，第二次GC时才能回收被引用对象。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-JVM执行引擎</title>
      <link href="/JVM-JVM%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/JVM-JVM%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM执行引擎"><a href="#JVM执行引擎" class="headerlink" title="JVM执行引擎"></a>JVM执行引擎</h1><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051418555.jpg"></p><h2 id="1、执行引擎概述"><a href="#1、执行引擎概述" class="headerlink" title="1、执行引擎概述"></a>1、执行引擎概述</h2><ul><li><p>执行引擎是Java虚拟机的核心组成部分之一。</p></li><li></li></ul><p>虚拟机是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而&#x3D;&#x3D;虚拟机的执行引擎则是由软件自行实现&#x3D;&#x3D;的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p><ul><li><p>JVM的主要任务是&#x3D;&#x3D;负责装载字节码到其内部&#x3D;&#x3D;，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表和其他辅助信息</p></li><li><p>那么，如果想让一个Java程序运行起来、执行引擎的任务就是&#x3D;&#x3D;将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以&#x3D;&#x3D;。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者.</p></li><li><p>工作过程</p><ul><li><p>从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p></li><li><p>具体工作过程</p><ul><li><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051418949" alt="img"></li></ul><ol><li><p>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</p></li><li><p>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</p></li><li><p>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</p></li></ol></li></ul></li></ul><h2 id="2、Java代码编译执行过程"><a href="#2、Java代码编译执行过程" class="headerlink" title="2、Java代码编译执行过程"></a>2、Java代码编译执行过程</h2><ul><li><h3 id="大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤"><a href="#大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤" class="headerlink" title="大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤"></a>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下面图中的各个步骤</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051418888" alt="img"></p><ul><li>解释型语言走中间一行</li><li>编译型语言走下边一行</li></ul></li><li><h3 id="Java代码编译是由Java源码编译器来完成的"><a href="#Java代码编译是由Java源码编译器来完成的" class="headerlink" title="Java代码编译是由Java源码编译器来完成的"></a>Java代码编译是由Java源码编译器来完成的</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051418187" alt="img"></p></li><li><h3 id="Java字节码的执行是由JVM执行引擎来完成的"><a href="#Java字节码的执行是由JVM执行引擎来完成的" class="headerlink" title="Java字节码的执行是由JVM执行引擎来完成的"></a>Java字节码的执行是由JVM执行引擎来完成的</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051418092" alt="img"></p></li><li><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p></li><li><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><p>就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p></li><li><h3 id="为什么说Java是半编译半解释型语言？"><a href="#为什么说Java是半编译半解释型语言？" class="headerlink" title="为什么说Java是半编译半解释型语言？"></a>为什么说Java是半编译半解释型语言？</h3><p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。<br>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051418156" alt="a"></p></li></ul><h2 id="3、机器码，指令，汇编语言"><a href="#3、机器码，指令，汇编语言" class="headerlink" title="3、机器码，指令，汇编语言"></a>3、机器码，指令，汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ul><li>各种用二进制编码方式表示的指令，叫做&#x3D;&#x3D;机器指令码&#x3D;&#x3D;。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li><li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li></ul><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><ul><li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li><li>如常见的<ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul></li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul><li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</li></ul></li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul><li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</li><li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。<br><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051419306.png" alt="image-20210712102610135"></li></ul><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ul><li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li><li>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</li><li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。<ul><li>字节码的典型应用为Java bytecode</li></ul></li></ul><h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p><ul><li>编译过程：是读取源程序（字符流），对 之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li><li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。<br><img src="https://raw.githubusercontent.com/shaoxiongdu/images/main/images/172933609774cda3" alt="img"></li></ul><h2 id="4、解释器"><a href="#4、解释器" class="headerlink" title="4、解释器"></a>4、解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了&#x3D;&#x3D;满足Java程序实现跨平台特性&#x3D;&#x3D;，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。 <img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051419781" alt="img"></p><ul><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li></ul><p>在Java的发展历史里，一共有两套解释执行器，即古老的&#x3D;&#x3D;字节码解释器&#x3D;&#x3D;、现在普遍使用的&#x3D;&#x3D;模板解释器&#x3D;&#x3D;。</p><ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。· - 而模板解释器将每一 条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。<ul><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ul></li></ul><h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><ul><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、 Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C+ +程序员所调侃。</li><li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ul><h2 id="5、编译器"><a href="#5、编译器" class="headerlink" title="5、编译器"></a>5、编译器</h2><h3 id="5-1、HotSpot-VM-为何解释器与T编译器共存"><a href="#5-1、HotSpot-VM-为何解释器与T编译器共存" class="headerlink" title="5.1、HotSpot VM 为何解释器与T编译器共存"></a>5.1、HotSpot VM 为何解释器与T编译器共存</h3><p>java代码的执行分类：</p><ul><li>第一种是将源代码编译成字节码文件，然后再运行时通过解释器将字节码文件转为机器码执行</li><li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT,Just In Time）将方法编译成机器码后再执行</li></ul><p>HotSpot<br>VM是目前市面上高性能虛拟机的代表作之一。它采用&#x3D;&#x3D;解释器与即时编译器并存的架构&#x3D;&#x3D;。在Java虛拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。<br>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。</p><h4 id="解释器依然存在的必要性"><a href="#解释器依然存在的必要性" class="headerlink" title="解释器依然存在的必要性"></a>解释器依然存在的必要性</h4><p>有些开发人员会感觉到诧异，既然HotSpotVM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><p><strong>首先明确</strong>：<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p><strong>所以</strong>：<br>尽管JRockitVM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一一个平衡点。在此模式下，&#x3D;&#x3D;当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。&#x3D;&#x3D;</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h4 id="HostSpot-JVM的执行方式"><a href="#HostSpot-JVM的执行方式" class="headerlink" title="HostSpot JVM的执行方式"></a>HostSpot JVM的执行方式</h4><p>当虛拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，&#x3D;&#x3D;根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。&#x3D;&#x3D;</p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。</p><p>​<br>曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420011" alt="9"></p><h3 id="5-2、-JIT编译器"><a href="#5-2、-JIT编译器" class="headerlink" title="5.2、 JIT编译器"></a>5.2、 JIT编译器</h3><h4 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h4><ul><li>Java 语言的“编译器” 其实是一段“不确定”的操作过程，因为它可能是指一个&#x3D;&#x3D;前端编译器&#x3D;&#x3D;（其实叫“编译器的前端” 更准确一些）把.java文件转变成.class文件的过程；</li><li>也可能是指虚拟机的&#x3D;&#x3D;后端运行期编译器&#x3D;&#x3D;（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用&#x3D;&#x3D;静态提前编译器&#x3D;&#x3D;（AOT 编译器，Ahead Of Time Compiler）直接把. java文件编译成本地机器代码的过程。</li></ul><p>前端编译器： Sun的Javac、 Eclipse JDT中的增量式编译器（ECJ）<br>JIT编译器： HotSpot VM的C1、C2编译器。<br>AOT编译器： GNU Compiler for the Java （GCJ） 、Excelsior JET。</p><h4 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h4><p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”<br>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p><ul><li>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR （On<br>StackReplacement）编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠&#x3D;&#x3D;热点探测功能&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测&#x3D;&#x3D;。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个 方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter） 和回边计数器（BackEdge Counter） 。<ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul></li></ul><h5 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h5><ul><li>这个计数器就用于统计方法被调用的次数，它的默认阈值在Client 模式 下是1500 次，在Server 模式下是10000 次。超过这个阈值，就会触发JIT编译。</li><li>这个阈值可以通过虚拟机参数一XX ：CompileThreshold来人为设定。</li><li>当一个方法被调用时， 会先检查该方法是否存在被JIT编译过的版本，如<br>果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。<br><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420391" alt="10"></li></ul><p><strong>热度衰减</strong></p><ul><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，<br>如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay） ，而这段时间就称为此方法统计的半衰周期（Counter Half Life<br>Time）。</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外， 可以使用-XX： CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ul><h5 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h5><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边” （Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。<br><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420533" alt="11"></p><h4 id="HotSpot-VM-可以设置程序执行方式"><a href="#HotSpot-VM-可以设置程序执行方式" class="headerlink" title="HotSpot VM 可以设置程序执行方式"></a>HotSpot VM 可以设置程序执行方式</h4><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint： 完全采用解释器模式执行程序；</li><li>-Xcomp： 完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。<br><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051420032" alt="img"></li></ul><h5 id="测试解释器模式和JIT编译模式"><a href="#测试解释器模式和JIT编译模式" class="headerlink" title="测试解释器模式和JIT编译模式"></a>测试解释器模式和JIT编译模式</h5><p>测试表明：</p><ul><li>纯解释器模式速度最慢（JVM1.0版本用的就是纯解释器执行）</li><li>混合模式速度更快</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> *  -Xint  : 6520ms</span></span><br><span class="line"><span class="comment"> *  -Xcomp : 950ms</span></span><br><span class="line"><span class="comment"> *  -Xmixed : 936ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntCompTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumber</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//计算100以内的质数</span></span><br><span class="line">            label:</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= Math.sqrt(j); k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j % k == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span> label;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//System.out.println(j);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="HotSpot-VM-中的JIT分类"><a href="#HotSpot-VM-中的JIT分类" class="headerlink" title="HotSpot VM 中的JIT分类"></a>HotSpot VM 中的JIT分类</h4><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server<br>Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li>-client： 指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行&#x3D;&#x3D;简单和可靠的优化，耗时短&#x3D;&#x3D;。以达到更快的编译速度。</li></ul></li><li>-server： 指定Java虚拟机运行在Server模式下，并使用C2编译器。<ul><li>C2进行&#x3D;&#x3D;耗时较长的优化，以及激进优化&#x3D;&#x3D;。但优化的代码执行效率更高。</li></ul></li></ul><h5 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h5><ul><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、冗余消除。<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2.上有如下几种优化：（server模式下才会有这些优化，64位系统默认就是server模式）<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ul><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。<br>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“一server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>一般来讲，JIT编译出来的机器码性能比解释器高。</li><li>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</li></ul><h2 id="Graal编译器与AOT编译器"><a href="#Graal编译器与AOT编译器" class="headerlink" title="Graal编译器与AOT编译器"></a>Graal编译器与AOT编译器</h2><h3 id="Graal编译器"><a href="#Graal编译器" class="headerlink" title="Graal编译器"></a>Graal编译器</h3><ul><li>自JDK10起，HotSpot又加入一个全新的即时编译器： Graal编译器</li><li>编译效果短短几年时间就追评了C2编译器。未来可期。</li><li>目前，带着“实验状态”标签，需要使用开关参数 -XX： +UnlockExperimentalVMOptions 一XX： +UseJVMCICompiler去激活，才可以使用。</li></ul><h3 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h3><ul><li>jdk9引入了AOT编译器（静态提前编译器，Ahead Of Time Compiler）</li><li>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal 编译器，将所输入的Java 类文件转换为机器码，并存放至生成的动态共享库之中。</li><li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</li><li>最大好处： Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢”的不良体验。</li><li>缺点：<ul><li>破坏了java”一次编译，到处运行”，必须为每个不同硬件、oS编译对应的发行包。</li><li>降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux x64 java base</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-字符串常量池</title>
      <link href="/JVM-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/JVM-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><h2 id="一、字符串的基本特性"><a href="#一、字符串的基本特性" class="headerlink" title="一、字符串的基本特性"></a>一、字符串的基本特性</h2><ul><li><p>String：字符串，使用一对””来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>；<span class="comment">//字面量的定义方式 在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>（<span class="string">&quot;hello&quot;</span>）； 调用构造方法</span><br></pre></td></tr></table></figure></li><li><p>String声明为final的， 不可被继承</p></li><li><p>String 实现的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;,CharSequence &#123;</span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Serializable接口：表示字符串是支持序列化的。</li><li>实现了Comparable接口：表示String可以比较大小。</li><li>实现了CharSequence接口: 只读访问</li></ul></li><li><p>String：代表不可变的字符序列。简称：不可变性。</p><ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ul></li><li><p>&#x3D;&#x3D;字符串常量池中是不会存储相同内容的字符串的。&#x3D;&#x3D;</p><ul><li>字符串常量池是一个固定大小的Hashtable，如果放进StringPool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.<br>intern时性能会大幅下降。</li><li>使用一XX： StringTableSize可设置StringTable的长度</li><li>在jdk6中StringTable是固定的，就是1009的长度，对StringTableSize的大小设 置没有要求</li><li>在jdk7中，StringTable的长度默认值是60013</li><li>jdk8开始,1009是StringTable长度可设置的最小值</li></ul></li></ul><h2 id="二、字符串的内存分配"><a href="#二、字符串的内存分配" class="headerlink" title="二、字符串的内存分配"></a>二、字符串的内存分配</h2><ul><li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些 类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li><li>常量池就类似一.个Java系统级别提供的缓存。8种基本数据类型的常量 池都是系统协调的，String类 型的常量池比较特殊。它的主要使用方法有两种。<ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。<ul><li>比如： String info &#x3D; “abc” ；</li></ul></li><li>如果不是用双引号声明的String对象，可以使用String提供的intern（）方法。这个后面重点谈</li></ul></li><li>Java 6及以前，字符串常量池存放在永久代。</li><li>Java 7中Oracle的工程师对字符串池的逻辑做了很大的改变，即&#x3D;&#x3D;将字符串常量池的位置调整到Java堆内。&#x3D;&#x3D;<ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String. intern（）。</li></ul></li><li>Java8元空间，字符串常量在堆</li></ul><p><strong>StringTable为什么要调整</strong><br>①永久代permSize默认比较小;<br>②永久代的垃圾回收频率低;</p><h2 id="三、字符串的基本操作"><a href="#三、字符串的基本操作" class="headerlink" title="三、字符串的基本操作"></a>三、字符串的基本操作</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051431087.png" alt="image-20210702153353091"></p><blockquote><p>注释为当前字符串常量池中的字符串个数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//line 3</span></span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> &#123;<span class="comment">//line 6</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051431298.png" alt="image-20210702153923981"></p><h2 id="四、字符串的拼接操作"><a href="#四、字符串的拼接操作" class="headerlink" title="四、字符串的拼接操作"></a>四、字符串的拼接操作</h2><ul><li>1.常量与常量的拼接结果在常量池，原理是编译期优化</li><li>2.常量池中不会存在相同内容的常量。</li><li>3.&#x3D;&#x3D;拼接符号两端只要其中有一个是变量，结果就在堆中&#x3D;&#x3D;。变量拼接的原理是StringBuilder</li><li>4.如果拼接的结果调用intern（）方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。<br>JDK1.7之后，如果堆中有该字符串，则为了节约内存，字符串常量池中会创建一个指向堆中该字符串对象引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        String s2=<span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s1==s2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        String s1=<span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2=<span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s3=<span class="string">&quot;javaEE hadoop&quot;</span>;</span><br><span class="line">        String s4=<span class="string">&quot;javaEE&quot;</span>+<span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEE hadoop</span></span><br><span class="line">        String s5=s1+<span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s6=<span class="string">&quot;javaEE&quot;</span>+s2;</span><br><span class="line">        String s7=s1+s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3==s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3==s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3==s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3==s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5==s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5==s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6==s7);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//intern():判断字符串常量池中是否存在javaEE hadoop值，如果存在，则返回常量池中javaEE hadoop的地址；</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中不存在javaEE hadoop，则在常量池中加载一份javaEE hadoop，并返回次对象的地址。</span></span><br><span class="line">        String s8=s6.intern();</span><br><span class="line">        System.out.println(s3==s8);<span class="comment">//true</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">        ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">        ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">        ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        补充：在jdk5.0之后使用的是StringBuilder,</span></span><br><span class="line"><span class="comment">        在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE hadoop&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051432568.png" alt="image-20210702174050699"></p><h3 id="拼接操作与append的效率对比"><a href="#拼接操作与append的效率对比" class="headerlink" title="拼接操作与append的效率对比"></a>拼接操作与append的效率对比</h3><p>append效率要比字符串拼接高很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</span></span><br><span class="line"><span class="comment">    详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</span></span><br><span class="line"><span class="comment">          使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</span></span><br><span class="line"><span class="comment">         ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</span></span><br><span class="line"><span class="comment">               StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        method1(100000);//4014</span></span><br><span class="line">        method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">            src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">        <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">            src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五、intern-的使用"><a href="#五、intern-的使用" class="headerlink" title="五、intern()的使用"></a>五、intern()的使用</h2><ul><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法： intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p></li><li><p>比如： String myInfo &#x3D; new String(“I love u”).intern()；<br>也就是说，如果在任意字符串上调用String. intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下 列表达式的值必定是true：<br>（”a” + “b” + “c”）.intern（）&#x3D;&#x3D; “abc”;<br>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）。</p></li></ul><h3 id="new-String-“ab”-会创建几个对象"><a href="#new-String-“ab”-会创建几个对象" class="headerlink" title="new String(“ab”)会创建几个对象"></a>new String(“ab”)会创建几个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        String str = new String(&quot;ab&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>new String(“ab”)会创建几个对象？看字节码，就知道是两个。</p><ul><li><p>一个对象是：new关键字在堆空间创建的</p></li><li><p>另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc</p></li><li><p>字节码</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051432416.png" alt="image-20210702164214084"></p></li></ul></li></ul><h3 id="new-String-“a”-new-String-“b”-呢？"><a href="#new-String-“a”-new-String-“b”-呢？" class="headerlink" title="new String(“a”) + new String(“b”)呢？"></a>new String(“a”) + new String(“b”)呢？</h3><ul><li><p>对象1：new StringBuilder()</p></li><li><p>对象2： new String(“a”)</p></li><li><p>对象3： 常量池中的”a”</p></li><li><p>对象4： new String(“b”)</p></li><li><p>对象5： 常量池中的”b”</p></li><li><p>深入剖析： StringBuilder的toString():</p></li><li><p>对象6 ：new String(“ab”)</p></li><li><p>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</p></li></ul><h3 id="关于String-intern-的面试题"><a href="#关于String-intern-的面试题" class="headerlink" title="关于String.intern()的面试题"></a>关于String.intern()的面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>); <span class="comment">//s  指向堆空间&quot;1&quot;的内存地址 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;  此时s1指向字符串常量池中&quot;1&quot;的内存地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//s2 指向字符串常量池已存在的&quot;1&quot;的内存地址  所以 s1==s2</span></span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//jdk6: true   jdk7/8：true</span></span><br><span class="line">        System.out.println(System.identityHashCode(s));<span class="comment">//491044090</span></span><br><span class="line">        System.out.println(System.identityHashCode(s1));<span class="comment">//644117698</span></span><br><span class="line">        System.out.println(System.identityHashCode(s2));<span class="comment">//644117698</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。</span></span><br><span class="line">        <span class="comment">//         jdk7:此时常量池中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">        s3.intern();</span><br><span class="line">        <span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、字符串-常量池的垃圾回收"><a href="#六、字符串-常量池的垃圾回收" class="headerlink" title="六、字符串 常量池的垃圾回收"></a>六、字符串 常量池的垃圾回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; 100; j++) &#123;</span></span><br><span class="line"><span class="comment">//            String.valueOf(j).intern();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//发生垃圾回收行为</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051432165.png" alt="image-20210702171046766"></p><h2 id="七、G1中的字符串去重操作"><a href="#七、G1中的字符串去重操作" class="headerlink" title="七、G1中的字符串去重操作"></a>七、G1中的字符串去重操作</h2><ul><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>➢堆存活数据集合里面String对象占了25%</li><li>➢堆存活数据集合里面重复的String对象有13.5%</li><li>➢String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用 里面，Java堆中存活的数据集合差不多25%是String对象。更进一一步，这里面差不多一半String对象是重复的，重复的意思是说： string1. equals<br>（string2）&#x3D;&#x3D;true。堆上存在重复的string对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>➢当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>➢如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>➢使用一个hashtable来记录所有的被String对象使用的不重复的char数组。 当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>➢如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>➢如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><ul><li>➢UseStringDeduplication （bool） ：开启String去重，默认是不开启的，需要手动开启。</li><li>➢PrintStringDedupl icationStatistics （bool） ：打印详细的去重统计信息，</li><li>➢StringDedupl icationAgeThreshold （uintx） ：达到这个年龄的string对象被认.为是去重的候选对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-对象的实例化内存布局与访问定位+直接内存</title>
      <link href="/JVM-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"/>
      <url>/JVM-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的实例化内存布局与访问定位-直接内存"><a href="#对象的实例化内存布局与访问定位-直接内存" class="headerlink" title="对象的实例化内存布局与访问定位+直接内存"></a>对象的实例化内存布局与访问定位+直接内存</h1><h2 id="一、对象的实例化"><a href="#一、对象的实例化" class="headerlink" title="一、对象的实例化"></a>一、对象的实例化</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430476.png" alt="image-20210627105217499"></p><h3 id="1、创建对象的方式"><a href="#1、创建对象的方式" class="headerlink" title="1、创建对象的方式"></a>1、创建对象的方式</h3><ul><li>new<ul><li>最常见的方式</li><li>变形1 ： Xxx的静态方法</li><li>变形2 ： XxBuilder&#x2F;XxoxFactory的静态方法</li></ul></li><li>Class的newInstance（）：反射的方式，只能调用空参的构造器，权限必须是public</li><li>Constructor的newInstance（Xxx）：反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用clone（） ：不调用任何构造器，当前类需要实现Cloneable接口，实现clone（）</li><li>使用反序列化：从文件中、从网络中获取一个对象的二进制流</li><li>第三方库Objenesis</li></ul><h3 id="2、创建对象的步骤"><a href="#2、创建对象的步骤" class="headerlink" title="2、创建对象的步骤"></a>2、创建对象的步骤</h3><ol><li><h4 id="判断对象对应的类是否加载、链接、初始化"><a href="#判断对象对应的类是否加载、链接、初始化" class="headerlink" title="判断对象对应的类是否加载、链接、初始化"></a>判断对象对应的类是否加载、链接、初始化</h4><p>​ 检查元空间的常量池中是否有类的符号引用，检查是否加载链接初始化。</p><ul><li><p>如果是，则生成对应的Class文件。</p></li><li><p>如果否，则在双亲委派机制模式下，使用当前类以 【ClassLoader+包名+类名】为Key查找对应的.class文件。</p><ul><li>如果找到，进行加载，生成对应的Class文件。</li><li>如果找不到，爆出ClassNotFoundException</li></ul></li></ul></li><li><h4 id="为对象分配内存"><a href="#为对象分配内存" class="headerlink" title="为对象分配内存"></a>为对象分配内存</h4><ol><li>计算对象占用大小，堆中分配对应字节。如果实例变量是引用变量，仅分配4个字节。</li></ol><ul><li><h2 id="如果内存规整：指针碰撞"><a href="#如果内存规整：指针碰撞" class="headerlink" title="如果内存规整：指针碰撞"></a>如果内存规整：指针碰撞</h2><p>所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact<br>（整理）过程的收集器时，使用指针碰撞。</p></li><li><p>如果内存不规整：空闲列表</p><ul><li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虛拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表（Free<br>List）。</li></ul></li><li><p>说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p></li><li><p>给对象的属性赋值的操作先后顺序：<br>① 属性的默认初始化<br>② 显式初始化&#x2F;代码块中初始化 （谁在前先谁执行）<br>③ 构造器中初始化</p></li></ul></li><li><h4 id="处理并发安全问题"><a href="#处理并发安全问题" class="headerlink" title="处理并发安全问题"></a>处理并发安全问题</h4><ol><li>CAS （ Compare And Swap ）失败重试、区域加锁：保证指针更新操作的原子性；</li><li>TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆的伊甸园区中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer）<br>虚拟机是否使用TLAB，可以通过一XX：+UseTLAB参数来 设定。</li></ol></li><li><h4 id="初始化分配到的空间"><a href="#初始化分配到的空间" class="headerlink" title="初始化分配到的空间"></a>初始化分配到的空间</h4><p>内存分配结束，虚拟机将分配到的内存空间都初始化为零值。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><h4 id="设置对象的对象头"><a href="#设置对象的对象头" class="headerlink" title="设置对象的对象头"></a>设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p></li><li><h4 id="执行init方法进行初始化"><a href="#执行init方法进行初始化" class="headerlink" title="执行init方法进行初始化"></a>执行init方法进行初始化</h4><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之<br>后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p></li></ol><p>加载类元信息 -》 为对象分配内存 -》处理并发问题 -》属性的默认初始化 -》设置对象头 -》init方法</p><h2 id="二、对象的内存布局"><a href="#二、对象的内存布局" class="headerlink" title="二、对象的内存布局"></a>二、对象的内存布局</h2><h3 id="1、对象头"><a href="#1、对象头" class="headerlink" title="1、对象头"></a>1、对象头</h3><ul><li>运行时元数据<ul><li>哈希值（ HashCode ）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li>类型指针：指向类元数据的InstanceKlass，确定该对象所属的类型</li></ul><blockquote><p>说明：如果是数组，还需记录数组的长度</p></blockquote><h3 id="2、实例数据"><a href="#2、实例数据" class="headerlink" title="2、实例数据"></a>2、实例数据</h3><p>​ 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） 规则：</p><ul><li>相同宽度的字段总被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="3、填充"><a href="#3、填充" class="headerlink" title="3、填充"></a>3、填充</h3><p>不是必须的，也没特别含义，仅仅起到占位符作用</p><h3 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430083.png" alt="image-20210627174946976"></p><h2 id="三、对象的访问定位"><a href="#三、对象的访问定位" class="headerlink" title="三、对象的访问定位"></a>三、对象的访问定位</h2><p>JVM是如何通过栈帧中的对象引|用访问到其内部的对象实例的呢？-&gt; 定位,通过栈上reference访问</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430458.png" alt="image-20210627175307489"></p><h3 id="对象访问的主要方式有两种"><a href="#对象访问的主要方式有两种" class="headerlink" title="对象访问的主要方式有两种"></a>对象访问的主要方式有两种</h3><ul><li><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430989.png" alt="image-20210627175414002"></p><ul><li><p>缺点：效率较低，需要专门开辟空间存储指针</p></li><li><p>优点：比较稳定，当指针修改时，栈帧中的引用不需要改，只改堆中对应的句柄池即可。</p></li></ul></li><li><h4 id="直接指针-HotSpot采用"><a href="#直接指针-HotSpot采用" class="headerlink" title="直接指针(HotSpot采用)"></a>直接指针(HotSpot采用)</h4></li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430814.png" alt="image-20210627175425488"></p><h2 id="四、直接内存"><a href="#四、直接内存" class="headerlink" title="四、直接内存"></a>四、直接内存</h2><ul><li><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</p></li><li><p>直接内存是Java堆外的、直接向系统申请的内存区间</p></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span></span><br><span class="line"><span class="comment"> *  byte[] / char[]     Buffer</span></span><br><span class="line"><span class="comment"> *  Stream              Channel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看直接内存的占用与释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存分配完毕，请求指示！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>来源于NIO（1.7之后的new I&#x2F;O），通过存在堆中的DirectByteBuffer操作本地内存</p><ul><li><p>I&#x2F;O读取文件<img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430133.png" alt="image-20210627175859625"></p></li><li><p>NI&#x2F;O读取文件<img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051431096.png" alt="image-20210627175914929"></p></li><li><p>通常，访问直接内存的速度会优于Java堆。即读写性能高</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>也可能导致OutOfMemoryError异常:OutOfMemoryError: Direct buffer memory</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于一Xmx指定的最大 堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><ul><li>&#x3D;&#x3D;缺点&#x3D;&#x3D;<ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul></li></ul><p>直接内存大小可以通过MaxDirectMemorySize设置</p><p>如果不指定，默认与堆的最大值一Xmx参数值一致</p><blockquote><h4 id="java-进程占用内存-x3D-java堆-本地直接内存"><a href="#java-进程占用内存-x3D-java堆-本地直接内存" class="headerlink" title="java 进程占用内存&#x3D; java堆 + 本地直接内存"></a>java 进程占用内存&#x3D; java堆 + 本地直接内存</h4></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-方法区</title>
      <link href="/JVM-%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>/JVM-%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM虚拟机之方法区"><a href="#JVM虚拟机之方法区" class="headerlink" title="JVM虚拟机之方法区"></a>JVM虚拟机之方法区</h1><h2 id="一、栈，堆，方法区的交互关系"><a href="#一、栈，堆，方法区的交互关系" class="headerlink" title="一、栈，堆，方法区的交互关系"></a>一、栈，堆，方法区的交互关系</h2><h3 id="1、运行时数据区结构图"><a href="#1、运行时数据区结构图" class="headerlink" title="1、运行时数据区结构图"></a>1、<strong>运行时数据区结构图</strong></h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429977.png" alt="image-20210626114509388"></p><h3 id="2、堆、栈、方法区的交互关系"><a href="#2、堆、栈、方法区的交互关系" class="headerlink" title="2、堆、栈、方法区的交互关系"></a>2、<strong>堆、栈、方法区的交互关系</strong></h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429830.png" alt="image-20210626114521515"></p><h3 id="3、方法区在jdk7及jdk8的落地实现"><a href="#3、方法区在jdk7及jdk8的落地实现" class="headerlink" title="3、方法区在jdk7及jdk8的落地实现"></a>3、<strong>方法区在jdk7及jdk8的落地实现</strong></h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429699.png" alt="image-20210626151619008"></p><p>方法区是一种规范</p><ul><li>JDK1.7及之前，用&#x3D;&#x3D;永久代&#x3D;&#x3D;实现，使用虚拟机的内存</li><li>JDK1.8及以后，用&#x3D;&#x3D;元数据区&#x3D;&#x3D;实现，使用本地内存</li></ul><h2 id="二、方法区的理解"><a href="#二、方法区的理解" class="headerlink" title="二、方法区的理解"></a>二、方法区的理解</h2><ul><li><p>《Java虚拟机规范》中明确说明：‘尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。’但对于HotSpotJVM而言，方法区还有一个别名叫做Non-heap（非堆），目的就是要和堆分开。<br>所以，&#x3D;&#x3D;方法区可以看作是一块独立于Java堆的内存空间。&#x3D;&#x3D;</p></li><li><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域</p></li><li><p>方法区在JVM启动时就会被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的</p></li><li><p>方法区的大小，跟堆空间一样，可以选择固定大小或者可拓展</p></li><li><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：OOM。</p><ul><li>比如：<ul><li>加载大量的第三方jar包；</li><li>Tomcat部署的工程过多；</li><li>大量动态生成反射类；</li></ul></li></ul></li><li><p>关闭JVM就会释放这个区域的内存</p></li><li><p>isualvm查看加载类的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429763.png" alt="image-20210626152501186"></p></li></ul><h2 id="三、设置方法区大小与OOM"><a href="#三、设置方法区大小与OOM" class="headerlink" title="三、设置方法区大小与OOM"></a>三、设置方法区大小与OOM</h2><h3 id="1、设置大小"><a href="#1、设置大小" class="headerlink" title="1、设置大小"></a>1、设置大小</h3><ul><li><p>jdk7及以前：</p><ul><li>永久代初始分配大小:    -XX:PermSize来设置。默认值是20.75M</li><li>永久代最大空间：-XX :MaxPermSize来设定。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError ： PermGen space</li></ul></li><li><p>jdk8及以后：</p><ul><li>元空间初始分配大小：-XX:MetaspaceSize windows下默认为21M</li><li>元空间最大：-XX ：MaxMetaspaceSize windows默认为-1 即无限制</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。 如果元数据区发生溢出，虚拟机一样会拋出异常OutOfMemoryError： Metaspace</li><li>初始分配大小就是初始的高水位线，一旦触及这个水位线，Full<br>GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，.上 述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将- XX ：MetaspaceSize设置为一个相对较高的值。</li></ul></li><li><p>试验</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*  jdk7及以前：</span><br><span class="line">*  查询 jps  -&gt; jinfo -flag PermSize [进程id]</span><br><span class="line">*  -XX:PermSize=20m -XX:MaxPermSize=82m</span><br><span class="line">*</span><br><span class="line">*  jdk8及以后：</span><br><span class="line">*  查询 jps  -&gt; jinfo -flag MetaspaceSize [进程id]</span><br><span class="line">*  -XX:MetaspaceSize=20.79m  -XX:MaxMetaspaceSize=-1</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="2、方法区OOM"><a href="#2、方法区OOM" class="headerlink" title="2、方法区OOM"></a>2、方法区OOM</h3><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTestMetaSpace</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OOMTestMetaSpace</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTestMetaSpace</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果爆出OOM</p><p><img src="https://gitee.com/ShaoxiongDu/imageBed/raw/master/image-20210626155904640.png"></p><p>1、要解决00M异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）<br>对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory 0verflow） 。</p><p>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC<br>Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p><p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（一Xmx与一Xms）<br>，与机器物理内存对比看是否还可以调大，从代码_上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ul><h2 id="四、方法区的内部结构"><a href="#四、方法区的内部结构" class="headerlink" title="四、方法区的内部结构"></a>四、方法区的内部结构</h2><h3 id="1、方法区在运行时数据区中的位置"><a href="#1、方法区在运行时数据区中的位置" class="headerlink" title="1、方法区在运行时数据区中的位置"></a>1、方法区在运行时数据区中的位置</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429404.png" alt="image-20210626160816829"></p><h3 id="2、方法区存储的信息"><a href="#2、方法区存储的信息" class="headerlink" title="2、方法区存储的信息"></a>2、方法区存储的信息</h3><p>方法区用于存储已被虚拟机加载的&#x3D;&#x3D;类型信息、常量、静态变量、即时编译器编译后的代码缓存&#x3D;&#x3D;等。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429542.png" alt="image-20210626160857167"></p><ul><li>类型信息</li><li>运行时常量池</li><li>静态变量</li><li>域（属性）信息</li><li>方法信息</li><li>JIT代码缓存</li></ul><h4 id="2-1类型信息"><a href="#2-1类型信息" class="headerlink" title="2.1类型信息"></a>2.1类型信息</h4><ul><li>对每个加载的类型（ 类class、接口interface、枚举enum、注解annotation），JVM必 .须在方法区中存储以下类型信息：<ul><li>①这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>②这个类型直接父类的完整有效名（对于interface或是java. lang.Object，都没有父类）</li><li>③这个类型的修饰符（public， abstract， final的某个子集）</li><li>④这个类型直接实现接口的一个有序列表</li></ul></li></ul><h4 id="2-2域信息（成员变量-x2F-属性）"><a href="#2-2域信息（成员变量-x2F-属性）" class="headerlink" title="2.2域信息（成员变量&#x2F;属性）"></a>2.2域信息（成员变量&#x2F;属性）</h4><ul><li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p></li><li><p>域的相关信息包括：域名称、 域类型、域修饰符（public， private， protected， static， final， volatile， transient的某个子集）</p></li></ul><h4 id="2-3方法信息"><a href="#2-3方法信息" class="headerlink" title="2.3方法信息"></a>2.3方法信息</h4><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public， private， protected， static， final， synchronized， native ， abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract和native 方法除外）</li><li>异常表（ abstract和native方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h4 id="2-4non-final的类变量"><a href="#2-4non-final的类变量" class="headerlink" title="2.4non-final的类变量"></a>2.4non-final的类变量</h4><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例所共享，即使没有类实例你也可以访问它。</li><li><strong>全局常量 static final</strong> 在编译的时候就被分配赋值了。</li></ul><h4 id="2-5运行时常量池"><a href="#2-5运行时常量池" class="headerlink" title="2.5运行时常量池"></a>2.5运行时常量池</h4><p>要想弄清楚方法区的运行时常量池，必须先理解类文件中的常量池。因为运行时常量池是从常量池加载的。</p><h5 id="类文件中的常量池"><a href="#类文件中的常量池" class="headerlink" title="类文件中的常量池"></a>类文件中的常量池</h5><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429336.png" alt="image-20210626164021598"></p><ul><li><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Poo1 Table），包括各种字面量和对类型域和方法的符号引用。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429355.png" alt="image-20210626174847203"></p></li><li><p>一个 java 源文件中的类、接口，编译后产生一个字节码文件。而 Java<br>中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池.</p></li><li><p>比如如下代码，虽然只有 194 字节，但是里面却使用了 string、System、Printstream 及 Object 等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">Simpleclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayhelloo</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.Println (hello) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ul><li><p>几种在常量池内存储的数据类型包括：</p><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul></li><li><p>运行时常量池（ Runtime Constant Pool）是方法区的一部分。</p></li><li><p>常量池表（Constant Pool Table）是Class文件的一部分，&#x3D;&#x3D;用于存放编译期生成的各种字面量与符号引用&#x3D;&#x3D;，这部分内容将在类加载后存放到方法区的运行时常量池中。</p></li><li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p></li><li><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p></li><li><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p></li><li><p>运行时常量池，相对于Class文件常量池的另一重要特征是：&#x3D;&#x3D;具备动态性&#x3D;&#x3D;。</p></li><li><p>运行时常量池类似于传统编程语言中的符号表（symbol table） ，但是它所包含的数据却比符号表要更加丰富一些。</p></li><li><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</p></li></ul><h2 id="五、方法区使用举例"><a href="#五、方法区使用举例" class="headerlink" title="五、方法区使用举例"></a>五、方法区使用举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 0 sipush 500 // 将500放入操作数栈中</span><br><span class="line"> 3 istore_1 // 将变量操作数栈顶中的500存储到LV中</span><br><span class="line"> 4 bipush 100 // 将100放入操作数栈中</span><br><span class="line"> 6 istore_2 //将操作数栈顶中的100放入LV中</span><br><span class="line"> 7 iload_1 // 读取LV1 500</span><br><span class="line"> 8 iload_2 // 读取LV2 100</span><br><span class="line"> 9 idiv // 将LV1读取的值除以LV2读取的值</span><br><span class="line">10 istore_3 // 结果5存入LV3中</span><br><span class="line">11 bipush 50 //压入50到操作数栈顶</span><br><span class="line">13 istore 4 //将栈顶的50存入LV中</span><br><span class="line">15 getstatic #2 &lt;java/lang/System.out&gt;</span><br><span class="line">18 iload_3</span><br><span class="line">19 iload 4</span><br><span class="line">21 iadd</span><br><span class="line">22 invokevirtual #3 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">25 return</span><br></pre></td></tr></table></figure><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430013.png" alt="image-20210626180931785"></p><h2 id="六、方法区的演进细节"><a href="#六、方法区的演进细节" class="headerlink" title="六、方法区的演进细节"></a>六、方法区的演进细节</h2><ul><li><p>首先明确：只有HotSpot才有永久代。 BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虛拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p></li><li><p>针对HotSpot</p><p>| 版本         | 方法区实现                                                   |<br>  | ———— | ———————————————————— |<br>| jdk1.6及之前 | 静态变量及字符串常量池存放在永久代（方法区1.6的实现）上      |<br>| jdk1.7       | 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中 |<br>| jdk1.8及之后 | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆 |</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430296.png" alt="image-20210626181629116"></p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430077.png" alt="image-20210626181640746"></p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430503.png" alt="image-20210626181651386"></p></li></ul><h4 id="永久代为什么要被元空间替换"><a href="#永久代为什么要被元空间替换" class="headerlink" title="永久代为什么要被元空间替换"></a>永久代为什么要被元空间替换</h4><ul><li><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类.的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（ Metaspace ）。</p></li><li><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p></li><li><p>这项改动是很有必要的，原因有：</p><ul><li>1）为永久代设置空间大小是很难确定的。<ul><li>在某些场景下，如果动态加载类过多，容易产生Perm区的O0M。</li><li>比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 <code>&quot;Exception in thread&#39; dubbo client x.x connector’java.lang.OutOfMemoryError： PermGenspace&quot;</code></li><li>而元空间和永久代之间最大的区别在于：&#x3D;&#x3D;元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制&#x3D;&#x3D;。</li></ul></li><li>2）对永久代进行调优是很困难的。。</li></ul></li></ul><h4 id="StringTable-为什么要调整"><a href="#StringTable-为什么要调整" class="headerlink" title="StringTable 为什么要调整"></a>StringTable 为什么要调整</h4><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full GC<br>是老年代的空间不足、永久代不足时才会触发。这就导致了StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h2 id="七、方法区的垃圾回收"><a href="#七、方法区的垃圾回收" class="headerlink" title="七、方法区的垃圾回收"></a>七、方法区的垃圾回收</h2><p>有些人认为方法区（如Hotspot，虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java<br>虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 2GC 收集器就不支持类卸载）。<br>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 Hotspot<br>虚拟机对此区域未完全回收而导致内存泄漏。<br>方法区的垃圾收集主要回收两部分内容：常量池中废奔的常量和不再使用的类型</p><ul><li>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：<ul><li>1、类和接口的全限定名</li><li>2、字段的名称和描述符</li><li>3、方法的名称和描述符</li></ul></li><li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</li><li>回收废弃常量与回收Java堆中的对象非常类似。</li><li>·判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：<ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li><li>Java虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了一Xnoclassgc<br>参数进行控制，还可以使用一verbose：class以及一XX： +TraceClass一Loading、一XX：+TraceClassUnLoading查 看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051430192.png" alt="image-20210626184245791"></p><h2 id="常见面试"><a href="#常见面试" class="headerlink" title="常见面试"></a>常见面试</h2><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><h3 id="蚂蚁金服："><a href="#蚂蚁金服：" class="headerlink" title="蚂蚁金服："></a>蚂蚁金服：</h3><p>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面： JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面： Eden和Survivor的比例分配</p><h3 id="小米："><a href="#小米：" class="headerlink" title="小米："></a>小米：</h3><p>jvm内存分区，为什么要有新生代和老年代</p><h3 id="字节跳动："><a href="#字节跳动：" class="headerlink" title="字节跳动："></a>字节跳动：</h3><p>二面： Java的内存分区<br>二面：讲讲jvm运行时数据库区<br>什么时候对象会进入老年代？</p><h3 id="京东："><a href="#京东：" class="headerlink" title="京东："></a>京东：</h3><p>JVM的内存结构，Eden和Survivor比例 。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</p><h3 id="天猫："><a href="#天猫：" class="headerlink" title="天猫："></a>天猫：</h3><p>一面： Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面： JVM的内存模型，Java8做了什么修改</p><h3 id="拼多多："><a href="#拼多多：" class="headerlink" title="拼多多："></a>拼多多：</h3><p>JVM内存分哪几个区，每个区的作用是什么？</p><h3 id="美团："><a href="#美团：" class="headerlink" title="美团："></a>美团：</h3><p>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面： jvm内存分区，为什么要有新生代和老年代？</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-堆</title>
      <link href="/JVM-%E5%A0%86/"/>
      <url>/JVM-%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="一、堆的核心概述"><a href="#一、堆的核心概述" class="headerlink" title="一、堆的核心概述"></a>一、堆的核心概述</h2><p>一个进程对应一个jvm实例，同时包含多个线程，这些&#x3D;&#x3D;线程共享方法区和堆&#x3D;&#x3D;，每个&#x3D;&#x3D;线程独有程序计数器、本地方法栈和虚拟机栈&#x3D;&#x3D;。</p><ul><li><p>一个jvm实例只存在一个堆内存，堆也是java内存管理的核心区域</p></li><li><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间（堆内存的大小是可以调节的）</p></li><li><p>《Java虚拟机规范》规定，堆可以处于&#x3D;&#x3D;物理上不连续&#x3D;&#x3D;的内存空间中，但在&#x3D;&#x3D;逻辑上它应该被视为连续的&#x3D;&#x3D;</p></li><li><p>所有的线程共享java堆，在这里还可以划分&#x3D;&#x3D;线程私有的缓冲区&#x3D;&#x3D;（TLAB:Thread Local Allocation Buffer）.（面试问题：堆空间一定是所有线程共享的么？不是，TLAB线程在堆中独有的）</p></li><li><p>《Java虚拟机规范》中对java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p></li><li><p>从实际使用的角度看，“几乎”所有的对象的实例都在这里分配内存 （‘几乎’是因为可能存储在栈上）</p></li><li><p>数组或对象永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</p></li><li><p>堆，是GC(Garbage Collection，垃圾收集器)执行垃圾回收的重点区域</p></li></ul><h4 id="1、查看堆内存"><a href="#1、查看堆内存" class="headerlink" title="1、查看堆内存"></a>1、查看堆内存</h4><p>1、编写java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、设置堆大小 -Xms10m -Xmx10m （默认大小10m 最大10m）</p><p>3、终端运行jvisualvm 可以看到该进程的堆大小</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428488.png" alt="image-20210622120414862"></p><h4 id="2、堆的细分内存结构"><a href="#2、堆的细分内存结构" class="headerlink" title="2、堆的细分内存结构"></a>2、堆的细分内存结构</h4><ul><li>JDK7及以前<ul><li>逻辑：新生区（伊甸园区+新幸存者1区+幸存者2区）+养老区+永久区（方法区在1.7的实现）</li><li><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428830.png" alt="image-20210622161217211"></li></ul></li><li>JDK8及以后<ul><li>逻辑：新生区（伊甸园区+新幸存者1区+幸存者2区）+养老区+元空间(直接内存)（方法区在1.8的实现）</li></ul></li></ul><h2 id="二、设置堆大小与OOM"><a href="#二、设置堆大小与OOM" class="headerlink" title="二、设置堆大小与OOM"></a>二、设置堆大小与OOM</h2><h3 id="1、设置堆大小-新生代-老年代"><a href="#1、设置堆大小-新生代-老年代" class="headerlink" title="1、设置堆大小 (新生代+老年代)"></a>1、设置堆大小 (新生代+老年代)</h3><ul><li><p>-Xms 用于表示堆的起始内存 ms:memory start</p></li><li><p>-Xmx 用于设置堆的最大内存</p></li><li><p>默认情况下</p><ul><li>初始内存大小：物理内存大小&#x2F;64</li><li>最大内存大小：物理内存大小&#x2F;4</li></ul></li><li><p>&#x3D;&#x3D;通常会将-Xms和-Xmx两个参数配置相同的值&#x3D;&#x3D;，其目的就是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</p></li><li><p>一旦堆区中的内存大小超过 -Xmx所指定的最大内存时，将会抛出OOM异常</p></li><li><p>查看堆信息：-XX:+PrintGCDetails</p></li></ul><h3 id="2、-查看堆内存大小"><a href="#2、-查看堆内存大小" class="headerlink" title="2、 查看堆内存大小"></a>2、 查看堆内存大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);<span class="comment">//-Xms : 243M</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);<span class="comment">//-Xmx : 3612M</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);<span class="comment">//系统内存大小为：15.1875G</span></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);<span class="comment">//系统内存大小为：14.109375G</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置大小为600，打印为575，这是因为幸存者区S0和S1各占据了25m，</p><p>但是他们始终有一个是空的，存放对象的是伊甸园区和某一个幸存者区</p><h3 id="3、堆大小分析"><a href="#3、堆大小分析" class="headerlink" title="3、堆大小分析"></a>3、堆大小分析</h3><p>设置堆大小为600m 运行程序 -Xms600m</p><p>终端输入:jps 显示当前进程:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10132 Launcher</span><br><span class="line">3848</span><br><span class="line">4952 Jps</span><br><span class="line">7112 HeapSpaceInitial</span><br><span class="line">D:\JVMStudy&gt;jstat 7112</span><br></pre></td></tr></table></figure><p>​ 终端输入:jstat -gc 7112 表示打印7112进程的gc情况</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428414.png" alt="image-20210622170458055"></p><p>打印出的结果将前七项相加除以1024，得到的为600m。</p><h3 id="4、OOM"><a href="#4、OOM" class="headerlink" title="4、OOM"></a>4、OOM</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread<span class="string">&quot;main&quot;</span>java.lang.OutOfMemoryError:Java heap space</span><br><span class="line">        at cn.shaoxiongdu.chapter2.Picture.&lt;init&gt;(OOMTest.java:<span class="number">27</span>)</span><br><span class="line">        at cn.shaoxiongdu.chapter2.OOMTest.main(OOMTest.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure><h2 id="三、年轻代和老年代"><a href="#三、年轻代和老年代" class="headerlink" title="三、年轻代和老年代"></a>三、年轻代和老年代</h2><ul><li><p>存储在JVM中的java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速（存入新生代）</li><li>另外一类对象时生命周期非常长，在某些情况下还能与JVM的生命周期保持一致 (存入老年代)</li></ul></li><li><p>Java堆区进一步细分可以分为年轻代（YoungGen）和老年代（OldGen）</p><ul><li>其中年轻代可以分为伊甸园区（Eden）、新生区1（from）和新生区2（to）</li></ul></li><li><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428277.png" alt="image-20210622172128916"></p></li></ul><h3 id="设置新生代老年代参数"><a href="#设置新生代老年代参数" class="headerlink" title="设置新生代老年代参数"></a>设置新生代老年代参数</h3><ul><li><p>-XX:NewRatio&#x3D;x 表示老年代&#x2F;新生代 默认为2</p><ul><li>-XX:SurvivorRatio ：设置新生代中伊甸园区&#x2F;幸存者区。默认值是8</li><li>-XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略 （暂时用不到）</li><li>-Xmn:设置新生代的空间的大小。 （一般不设置）</li></ul></li><li><p>几乎所有的Java对象都是在Eden区被new出来的</p></li><li><p>绝大部分的Java对象都销毁在新生代了（IBM公司的专门研究表明，新生代80%的对象都是“朝生夕死”的）</p></li><li><p>可以使用选项-Xmn设置新生代最大内存大小（这个参数一般使用默认值就好了）</p></li></ul><h2 id="四、图解对象分配过程"><a href="#四、图解对象分配过程" class="headerlink" title="四、图解对象分配过程"></a>四、图解对象分配过程</h2><blockquote><p>为新对象分配内存是件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配的问题，并且由于内存分配算法与内存回收算法密切相关，<br>所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p></blockquote><h3 id="1、对象分配过程"><a href="#1、对象分配过程" class="headerlink" title="1、对象分配过程"></a>1、对象分配过程</h3><ol><li><p>new的对象先放伊甸园区。此区有大小限制。</p></li><li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。将伊甸园中的剩余对象移动到幸存者0区。</p></li><li><p>然后加载新的对象放到伊甸园区</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428427.png" alt="image-20210623140803974"></p></li><li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428458.png" alt="image-20210623140854954"></p></li><li><p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p></li><li><p>啥时候能去养老区呢？可以设置次数。默认是15次。·可以设置参数：</p><p>-XX:MaxTenuringThreshold&#x3D;进行设置。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428162.png" alt="image-20210623140931052"></p></li><li><p>在养老区，相对悠闲。当老年区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p></li><li><p>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常</p></li></ol><p>总结：</p><p>&#x3D;&#x3D;<strong>针对幸存者s0,s1区：复制之后有交换，谁空谁是to</strong>&#x3D;&#x3D;<br>&#x3D;&#x3D;<strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区&#x2F;元空间收集。</strong>&#x3D;&#x3D;</p><h3 id="2、对象分配的特殊情况"><a href="#2、对象分配的特殊情况" class="headerlink" title="2、对象分配的特殊情况"></a>2、对象分配的特殊情况</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428589.png" alt="image-20210623141531079"></p><h3 id="3、代码举例"><a href="#3、代码举例" class="headerlink" title="3、代码举例"></a>3、代码举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapInstanceTest</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HeapInstanceTest&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HeapInstanceTest</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428698.png" alt="image-20210623142658708"></p><p>说明：</p><pre><code>- 伊甸园区的分配如图所示，当分配的对象到达150M，则进行一次垃圾回收，将非垃圾放入幸存者1区，继续分配放入伊甸园区，到达150之后，将对象放入0区，并且将之前1区中的对象放入老年区，以此类推。直到老年区满400M，爆出OOM(OutOfMemory)异常。</code></pre><h3 id="4、常用调优工具"><a href="#4、常用调优工具" class="headerlink" title="4、常用调优工具"></a>4、常用调优工具</h3><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>VisualVM</li><li>Jprofiler</li><li>Java Flight Recorder</li><li>GCViewer</li><li>GC Easy</li></ul><h2 id="五、MinorGC-、MajorGC、Full-GC"><a href="#五、MinorGC-、MajorGC、Full-GC" class="headerlink" title="五、MinorGC 、MajorGC、Full GC"></a>五、MinorGC 、MajorGC、Full GC</h2><blockquote><p>JVM在进行GC时，并非每次都针对上面三个内存区域（新生代、老年代、方法区）一起回收的，大部分时候回收都是指新生代。</p></blockquote><p>针对hotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li><p>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集</p></li><li><p>部分收集</p><ul><li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集</li><li>目前，只有CMS GC会有单独收集老年代的行为</li><li>注意，&#x3D;&#x3D;很多时候Major GC 会和 Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收&#x3D;&#x3D;</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul><li>目前，之后G1 GC会有这种行为</li></ul></li></ul></li></ul><h2 id="六、堆空间分代思想"><a href="#六、堆空间分代思想" class="headerlink" title="六、堆空间分代思想"></a>六、堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了么</p><ul><li>经研究，不同对象的生命周期不同。70%-99%的对象都是临时对象。<ul><li>新生代：有Eden、Survivor构成（s0,s1 又称为from to），to总为空</li><li>老年代：存放新生代中经历多次依然存活的对象</li></ul></li><li>其实不分代完全可以，分代的唯一理由就是&#x3D;&#x3D;优化GC性能&#x3D;&#x3D;。<br>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。<br>GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描，而很多对象都是朝生夕死的。<br>如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li></ul><h2 id="七、提升到老年区的规则"><a href="#七、提升到老年区的规则" class="headerlink" title="七、提升到老年区的规则"></a>七、提升到老年区的规则</h2><p>如果对象在Eden出生并经过第一次Minor<br>GC后依然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，把那个将对象年龄设为1.对象在Survivor区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到一定程度（默认15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中</p><ul><li><h3 id="对象晋升老年代的年龄阈值，可以通过选项-XX：MaxTenuringThreshold来设置"><a href="#对象晋升老年代的年龄阈值，可以通过选项-XX：MaxTenuringThreshold来设置" class="headerlink" title="对象晋升老年代的年龄阈值，可以通过选项 -XX：MaxTenuringThreshold来设置"></a>对象晋升老年代的年龄阈值，可以通过选项 -XX：MaxTenuringThreshold来设置</h3></li></ul><p>针对不同年龄段的对象分配原则如下：</p><ul><li><h3 id="优先分配到Eden"><a href="#优先分配到Eden" class="headerlink" title="优先分配到Eden"></a>优先分配到Eden</h3></li><li><h3 id="大对象直接分配到老年代（尽量避免程序中出现过多的大对象）"><a href="#大对象直接分配到老年代（尽量避免程序中出现过多的大对象）" class="headerlink" title="大对象直接分配到老年代（尽量避免程序中出现过多的大对象）"></a>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</h3></li><li><h3 id="长期存活的对象分配到老年代"><a href="#长期存活的对象分配到老年代" class="headerlink" title="长期存活的对象分配到老年代"></a>长期存活的对象分配到老年代</h3></li><li><h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><ul><li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入到老年代。无需等到MaxTenuringThreshold中要求的年龄</li></ul></li><li><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul><li>-XX: HandlePromotionFailure</li></ul></li></ul><h3 id="2、代码测试"><a href="#2、代码测试" class="headerlink" title="2、代码测试"></a>2、代码测试</h3><p>分配60m堆空间，新生代 20m ，Eden 16m， s0 2m， s1 2m，buffer对象20m，Eden 区无法存放buffer， 直接晋升老年代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 测试：大对象直接进入老年代</span></span><br><span class="line"><span class="comment"> * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YoungOldAreaTest</span> &#123;</span><br><span class="line">    <span class="comment">// 新生代 20m ，Eden 16m， s0 2m， s1 2m</span></span><br><span class="line">    <span class="comment">// 老年代 40m</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Eden 区无法存放buffer  晋升老年代</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>];<span class="comment">//20m</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p>20m的buffer存放于老年代中</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428461.png" alt="image-20210623161830107"></p><h2 id="八、为对象分配内存：TLAB"><a href="#八、为对象分配内存：TLAB" class="headerlink" title="八、为对象分配内存：TLAB"></a>八、为对象分配内存：TLAB</h2><h3 id="1、为什么要有TLAB？"><a href="#1、为什么要有TLAB？" class="headerlink" title="1、为什么要有TLAB？"></a>1、为什么要有TLAB？</h3><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><h3 id="2、什么是TLAB"><a href="#2、什么是TLAB" class="headerlink" title="2、什么是TLAB"></a>2、<strong>什么是TLAB</strong></h3><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428120.png" alt="image-20210625201230387"></p><ul><li><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为&#x3D;&#x3D;快速分配策略&#x3D;&#x3D;</p></li><li><p>所有OpenJDK衍生出来的JVM都提供了TLAB的设计</p></li></ul><h3 id="3、说明"><a href="#3、说明" class="headerlink" title="3、说明"></a>3、说明</h3><ul><li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，单JV明确是是将TLAB作为内存分配的首选</p></li><li><p>在程序中，开发人员可以通过选项“-XX:UseTLAB“ 设置是够开启TLAB空间</p></li><li><p>默认情况下，TLAB空间的内存非常小，仅占有整个EDen空间的1%，当然我们可以通过选项 ”-XX:TLABWasteTargetPercent“ 设置TLAB空间所占用Eden空间的百分比大小</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配了内存</p></li></ul><h3 id="4、TLAB对象分配过程"><a href="#4、TLAB对象分配过程" class="headerlink" title="4、TLAB对象分配过程"></a>4、TLAB对象分配过程</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051428826.png" alt="image-20210625201540406"></p><h2 id="九、堆空间的参数设置"><a href="#九、堆空间的参数设置" class="headerlink" title="九、堆空间的参数设置"></a>九、堆空间的参数设置</h2><ul><li><p>XX:PrintFlagsInitial: 查看所有参数的默认初始值</p></li><li><p>XX:PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p>具体查看某个参数的指令：</p><ul><li>jps：查看当前运行中的进程</li><li>jinfo -flag SurvivorRatio 进程id： 查看新生代中Eden和S0&#x2F;S1空间的比例</li></ul></li><li><p>Xms: 初始堆空间内存（默认为物理内存的1&#x2F;64）</p></li><li><p>Xmx: 最大堆空间内存（默认为物理内存的1&#x2F;4）</p></li><li><p>Xmn: 设置新生代大小（初始值及最大值）</p></li><li><p>XX:NewRatio: 配置新生代与老年代在堆结构的占比</p></li><li><p>XX:SurvivorRatio：设置新生代中Eden和S0&#x2F;S1空间的比例</p></li><li><p>XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄(默认15)</p></li><li><p>XX:+PrintGCDetails：输出详细的GC处理日志</p></li><li><p>打印gc简要信息：① -XX:+PrintGC ② -verbose:gc</p></li><li><p>-XX:HandlePromotionFailure：是否设置空间分配担保</p></li></ul><h2 id="X、堆是分配对象的唯一选择吗"><a href="#X、堆是分配对象的唯一选择吗" class="headerlink" title="X、堆是分配对象的唯一选择吗"></a>X、堆是分配对象的唯一选择吗</h2><h3 id="1、逃逸分析概念"><a href="#1、逃逸分析概念" class="headerlink" title="1、逃逸分析概念"></a>1、逃逸分析概念</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：随着JIT编译期的发展与逃逸分析技术逐渐成熟，&#x3D;&#x3D;栈上分配、标量替换优化技术&#x3D;&#x3D;将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。<br>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过&#x3D;&#x3D;逃逸分析（Escape Analysis)<br>后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配&#x3D;&#x3D;。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><ul><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，&#x3D;&#x3D;对象只在方法内部使用，则认为没有发生逃逸&#x3D;&#x3D;。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li><li>&#x3D;&#x3D;如何快速的判断是否发生了逃逸分析，就看new的对象实体是否有可能在方法外被调用&#x3D;&#x3D;</li></ul><h3 id="2、代码分析"><a href="#2、代码分析" class="headerlink" title="2、代码分析"></a>2、代码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1,String s2)</span>&#123;</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="comment">//发生逃逸 因为外部使用了</span></span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有发生逃逸 外部没有使用</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3、结论"><a href="#3、结论" class="headerlink" title="3、结论"></a><strong>3、结论</strong></h3><p>开发中能使用局部变量的，就不要使用在方法外定义</p><h2 id="十一、逃逸分析之代码优化"><a href="#十一、逃逸分析之代码优化" class="headerlink" title="十一、逃逸分析之代码优化"></a>十一、逃逸分析之代码优化</h2><h3 id="1-、栈上分配"><a href="#1-、栈上分配" class="headerlink" title="1 、栈上分配"></a>1 、栈上分配</h3><ul><li><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成- 栈上分配。分配完成之后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须机型垃圾回收了</p></li><li><p>常见的不能栈上分配场景：给成员变量赋值、方法返回值、实例引用传递</p></li></ul><h5 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配100000个对象</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建对象</span></span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><ul><li>关闭逃逸分析 -XX:-DoEscapeAnalysis<ul><li>花费的时间为： 104 ms</li><li>维护10000个对象<img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429704.png" alt="image-20210625205057934"></li></ul></li><li>开启逃逸分析(默认开启)<ul><li>花费的时间为： 6 ms</li><li>维护少量对象<img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051429659.png" alt="image-20210625205306816"></li></ul></li></ul><h3 id="2、同步省略"><a href="#2、同步省略" class="headerlink" title="2、同步省略"></a>2、同步省略</h3><ul><li><p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</p></li><li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能</p></li><li></li></ul><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫&#x3D;&#x3D;锁消除&#x3D;&#x3D;</p><p>如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        Object hollis=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span>(hollis)&#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>代码中对hollis这个对象进行加锁，但是hollis对象的生命周期只在f（）方法中 并不会被其他线程所访问控制，所以在JIT编译阶段就会被优化掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">        Object hollis=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3、分离对象或标量替换"><a href="#3、分离对象或标量替换" class="headerlink" title="3、分离对象或标量替换"></a>3、分离对象或标量替换</h3><ul><li><p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p></li><li><p>&#x3D;&#x3D;标量Scalar&#x3D;&#x3D;是指一个无法在分解成更小的数据的数据。Java中的原始数据类型就是标量</p></li><li><p>相对的，那些还可以分解的数据叫做&#x3D;&#x3D;聚合量(Aggregate)&#x3D;&#x3D;，Java中对象就是聚合量，因为它可以分解成其他聚合量和标量</p></li><li><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来替代。这个过程就是标量替换</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        alloc();   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码会被优化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> y=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以&#x3D;&#x3D;大大减少堆内存的占用&#x3D;&#x3D;。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><h3 id="4、逃逸分析小结（技术并不成熟）"><a href="#4、逃逸分析小结（技术并不成熟）" class="headerlink" title="4、逃逸分析小结（技术并不成熟）"></a>4、逃逸分析小结（技术并不成熟）</h3><ul><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle<br>HotspotJVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li><li></li></ul><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：&#x3D;&#x3D;对象实例都是分配在堆上&#x3D;&#x3D;。</p><ul><li><strong>年轻代是对象的诞生、省长、消亡的区域，一个对象在这里产生、应用、最后被垃圾回收器收集、结束生命</strong></li><li>**<br>老年代防止长生命周期对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上，如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象他打，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代**</li><li><strong>当GC只发生在年轻代中，回收年轻对象的行为被称为MinorGC。当GC发生在老年代时则被称为MajorGC或者FullGC。一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率大大低于年轻代</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-本地方法栈</title>
      <link href="/JVM-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
      <url>/JVM-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><h2 id="一、本地方法栈在运行时数据区中的位置"><a href="#一、本地方法栈在运行时数据区中的位置" class="headerlink" title="一、本地方法栈在运行时数据区中的位置"></a>一、本地方法栈在运行时数据区中的位置</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051427068.png" alt="image-20210622112030112"></p><h2 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h2><ul><li><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong></li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态拓展的内存大小。（在内存溢出方面是相同的）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。</li></ul></li><li>本地方法是使用C语言实现的</li><li>它的具体做法是在虚拟机栈中登记native方法，在Execution Engine执行时加载本地方法库。</li><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限<ul><li>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在hotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-本地方法接口</title>
      <link href="/JVM-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
      <url>/JVM-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="一、在JVM中的位置"><a href="#一、在JVM中的位置" class="headerlink" title="一、在JVM中的位置"></a>一、在JVM中的位置</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051427213.png" alt="image-20210622110456863"></p><h2 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h2><p>简单来讲，<strong>一个Native Method就是一个java调用非java代码的接口</strong>，一个Native Method<br>是这样一个java方法：该方法的实现由非Java语言实现，比如C。这个特征并非java特有，很多其他的编程语言都有这一机制，比如在C++ 中，你可以用extern “C” 告知C++ 编译器去调用一个C的函数。<br>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。<br>本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C&#x2F;C++程序。<br>标识符native可以与其他所有的java标识符连用，但是abstract除外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//abstract 没有方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//native 和 abstract不能共存，native是有方法体的，由C语言来实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     使用native标识为本地方法接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">Native2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="type">float</span> <span class="title function_">Native3</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native4</span><span class="params">(<span class="type">int</span>[] array)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、为什么要使用Native-Method"><a href="#三、为什么要使用Native-Method" class="headerlink" title="三、为什么要使用Native Method"></a>三、为什么要使用Native Method</h2><p>Native使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><ul><li><h4 id="与java环境外交互："><a href="#与java环境外交互：" class="headerlink" title="与java环境外交互："></a>与java环境外交互：</h4><p>有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。<br>你可以想想java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐细节。</p></li><li><h4 id="与操作系统交互"><a href="#与操作系统交互" class="headerlink" title="与操作系统交互"></a>与操作系统交互</h4><p>JVM支持着java语言本身和运行库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至jvm的一些部分就是用C写的。还有，如果我们要使用一些java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。</p></li><li><h4 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h4><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()<br>方法是用Java实现的，但是它实现调用的事该类里的本地方法setPriority0（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32<br>SetProority（）API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p></li></ul><h2 id="四、现状"><a href="#四、现状" class="headerlink" title="四、现状"></a>四、现状</h2><p>目前该方法的是用越来越少了，除非是与硬件有关的应用，比如通过java程序驱动打印机或者java系统管理生产设备，在企业级应用已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以是用Web<br>Service等等，不多做介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-沙箱安全机制</title>
      <link href="/JVM-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/JVM-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、沙箱安全机制"><a href="#一、沙箱安全机制" class="headerlink" title="一、沙箱安全机制"></a>一、沙箱安全机制</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义:"></a>1、定义:</h2><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，<br>而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,<br>报错信息说没有main方法就是因为加载的是rt.jar包中的String类。<br>这样可以保证对java核心源代码的保护，这就是沙箱安全机制.</p><h2 id="2、类比举例"><a href="#2、类比举例" class="headerlink" title="2、类比举例"></a>2、类比举例</h2><h4 id="我们在读写U盘信息时可以用360沙箱，防止U盘内的病毒等对沙箱外的系统构成污染"><a href="#我们在读写U盘信息时可以用360沙箱，防止U盘内的病毒等对沙箱外的系统构成污染" class="headerlink" title="我们在读写U盘信息时可以用360沙箱，防止U盘内的病毒等对沙箱外的系统构成污染"></a>我们在读写U盘信息时可以用360沙箱，防止U盘内的病毒等对沙箱外的系统构成污染</h4><h1 id="二、其他"><a href="#二、其他" class="headerlink" title="二、其他"></a>二、其他</h1><h2 id="1、在jvm中表示两个class对象是否为同一个类存在的两个必要条件"><a href="#1、在jvm中表示两个class对象是否为同一个类存在的两个必要条件" class="headerlink" title="1、在jvm中表示两个class对象是否为同一个类存在的两个必要条件"></a>1、在jvm中表示两个class对象是否为同一个类存在的两个必要条件</h2><ul><li><p>类的完整类名必须一致，包括包名</p></li><li><p>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</p><p>换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的.</p></li></ul><h2 id="2、对类加载器的引用"><a href="#2、对类加载器的引用" class="headerlink" title="2、对类加载器的引用"></a>2、对类加载器的引用</h2><p>JVM必须知道一个类型是有启动类加载器加载的还是由用户类加载器加载的。如果一个类型由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的会议部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的加载器是相同的。</p><h2 id="3、类的主动使用和被动使用"><a href="#3、类的主动使用和被动使用" class="headerlink" title="3、类的主动使用和被动使用"></a>3、类的主动使用和被动使用</h2><p>​ java程序对类的使用方式分为：主动使用和被动使用</p><ul><li><p>主动使用，分为七种情况</p><ol><li>创建类的实例</li><li>访问某各类或接口的静态变量，或者对静态变量赋值</li><li>调用类的静态方法</li><li>反射 比如Class.forName(com.dsh.jvm.xxx)</li><li>初始化一个类的子类</li><li>java虚拟机启动时被标明为启动类的类</li><li>JDK 7 开始提供的动态语言支持：</li><li>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol></li><li><p>除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-运行时数据区内部结构</title>
      <link href="/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/"/>
      <url>/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区内部结构"><a href="#运行时数据区内部结构" class="headerlink" title="运行时数据区内部结构"></a>运行时数据区内部结构</h1><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051416645.jpg"></p><h2 id="一、内存"><a href="#一、内存" class="headerlink" title="一、内存"></a>一、内存</h2><p>内存是非常重要的系统资源，是硬盘和cpu的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了JAVA在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。**<br>不同的jvm对于内存的划分方式和管理机制存在着部分差异**（对于Hotspot主要指方法区）</p><h2 id="二、运行时数据区在JVM中的位置"><a href="#二、运行时数据区在JVM中的位置" class="headerlink" title="二、运行时数据区在JVM中的位置"></a>二、运行时数据区在JVM中的位置</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051416985.jpg" alt="运行时数据区在JVM中的位置"></p><h2 id="三、运行时数据区体内部结构"><a href="#三、运行时数据区体内部结构" class="headerlink" title="三、运行时数据区体内部结构"></a>三、运行时数据区体内部结构</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051416887.png"></p><blockquote><p>一个进程对应一个jvm实例，一个运行时数据区，又包含多个线程，这些线程共享了方法区和堆，每个线程包含了程序计数器、本地方法栈和虚拟机栈。</p></blockquote><h5 id="注：-方法区对应JDK8之后的元数据区"><a href="#注：-方法区对应JDK8之后的元数据区" class="headerlink" title="注： 方法区对应JDK8之后的元数据区"></a>注： 方法区对应JDK8之后的元数据区</h5><h2 id="四、分区介绍"><a href="#四、分区介绍" class="headerlink" title="四、分区介绍"></a>四、分区介绍</h2><p>java虚拟机定了了若干种程序运行期间会使用到的运行时数据区</p><ul><li>其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁，红色区域部分</li><li>另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。灰色区域部分</li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051416160.png" alt="image-20210618141258229"></p><p>每一个JVM实例都对应一个RunTime实例，即运行时环境。相当于上图中的框内部分。</p><h2 id="五、线程"><a href="#五、线程" class="headerlink" title="五、线程"></a>五、线程</h2><ul><li><p>线程是一个程序里的运行单元，JVM允许一个程序有多个线程并行的执行；</p></li><li><p>在HotSpot JVM，每个线程都与操作系统的本地线程直接映射。</p></li><li><p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收。</p></li><li><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用java线程中的run（）方法.</p></li></ul><h2 id="六、JVM系统线程"><a href="#六、JVM系统线程" class="headerlink" title="六、JVM系统线程"></a>六、JVM系统线程</h2><ul><li>如果你使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用main方法的main线程以及所有这个main线程自己创建的线程；</li><li>这些主要的后台系统线程在HotSpot JVM里主要是以下几个：<ul><li>虚拟机线程这种线程的操作时需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。<br>这种线程的执行包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li>周期任务线程：这种线程是时间周期事件的提现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对于JVM里不同种类的垃圾收集行为提供了支持</li><li>编译线程：这种线程在运行时会降字节码编译成本地代码</li><li>信号调度线程：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-虚拟机栈</title>
      <link href="/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
      <url>/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="一、虚拟机栈概述"><a href="#一、虚拟机栈概述" class="headerlink" title="一、虚拟机栈概述"></a>一、虚拟机栈概述</h2><h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><p>由于跨平台性的设计，java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。<br><strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</strong></p><h3 id="2、内存中的堆与栈"><a href="#2、内存中的堆与栈" class="headerlink" title="2、内存中的堆与栈"></a>2、内存中的堆与栈</h3><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051426875.png" alt="image-20210621094710288"></p><ul><li><strong>栈</strong><ul><li>运行时的单位。</li><li>解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>存放基本数据类型的局部变量，以及引用数据类型的对象的引用。</li></ul></li><li><strong>堆</strong><ul><li>是存储的单位。</li><li>堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</li><li>对象主要都是放在堆空间的，是运行时数据区比较大的一块。</li></ul></li></ul><h4 id="3、虚拟机栈是什么"><a href="#3、虚拟机栈是什么" class="headerlink" title="3、虚拟机栈是什么"></a>3、虚拟机栈是什么</h4><ul><li>java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应这个一次次的java方法调用。它是线程私有的</li><li>生命周期和线程是一致的</li><li>作用：主管java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。<ul><li>局部变量：相对于成员变量（或属性）</li><li>基本数据变量： 相对于引用类型变量（类，数组，接口）</li></ul></li></ul><h4 id="4、-栈的特点"><a href="#4、-栈的特点" class="headerlink" title="4、 栈的特点"></a>4、 栈的特点</h4><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）- JVM直接对java栈的操作只有两个<ul><li>每个方法执行，伴随着进栈（入栈，压栈）</li><li>执行结束后的出栈工作</li></ul></li><li>对于栈来说不存在垃圾回收问题</li></ul><h4 id="5、-栈的常见异常"><a href="#5、-栈的常见异常" class="headerlink" title="5、 栈的常见异常"></a>5、 栈的常见异常</h4><p>​ java虚拟机规范**&#x3D;&#x3D;允许Java栈的大小是动态的或者是固定不变的&#x3D;&#x3D;**</p><ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 &#x3D;&#x3D;<strong>StackOverFlowError</strong><br>异常&#x3D;&#x3D;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverFlowErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//递归调用main</span></span><br><span class="line">    main(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 递归调用main，当主线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 &#x3D;&#x3D;StackOverFlowError异常&#x3D;&#x3D;。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051426607.png" alt="image-20210621101633260"></p><ul><li>如果java虚拟机栈动态拓展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个 <strong>&#x3D;&#x3D;OutOfMemoryError异常&#x3D;&#x3D;</strong></li></ul><h4 id="6、设置栈的内存大小"><a href="#6、设置栈的内存大小" class="headerlink" title="6、设置栈的内存大小"></a>6、设置栈的内存大小</h4><p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小-Xss256k）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示设置栈的内存大小</span></span><br><span class="line"><span class="comment"> * 默认情况下：1M  count 11404 </span></span><br><span class="line"><span class="comment"> * 栈大小： -Xss256k count 2466</span></span><br><span class="line"><span class="comment"> * 栈大小： -Xss128m count 1656372</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、栈的存储单位"><a href="#二、栈的存储单位" class="headerlink" title="二、栈的存储单位"></a>二、栈的存储单位</h2><h4 id="1、栈的运行原理"><a href="#1、栈的运行原理" class="headerlink" title="1、栈的运行原理"></a>1、栈的运行原理</h4><ul><li>每个线程都有自己的栈，栈中的数据都是以**栈帧(Stack Frame)**的格式存在</li><li>在这个线程上正在执行的每个方法都对应各自的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息- JVM直接对java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出&#x2F;后进先出的和原则。</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧(Current Frame)</strong>,与当前栈帧对应的方法就是<strong>当前方法（Current<br>Method）</strong></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前栈帧。</li><li>不同线程中所包含的栈帧是不允许相互引用的，即不可能在另一个栈帧中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></li></ul><h4 id="2、栈帧内部的组成结构"><a href="#2、栈帧内部的组成结构" class="headerlink" title="2、栈帧内部的组成结构 "></a>2、栈帧内部的组成结构 <img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051426582.png" alt="image-20210621103004204"></h4><p>每个栈帧中存储着：</p><ul><li>&#x3D;&#x3D;局部变量表&#x3D;&#x3D;（Local Variables）</li><li>&#x3D;&#x3D;操作数栈&#x3D;&#x3D;（Operand Stack）(或表达式栈)</li><li>&#x3D;&#x3D;动态链接&#x3D;&#x3D;（Dynamic Linking）(或执行运行时常量池的方法引用)</li><li>&#x3D;&#x3D;方法返回地址&#x3D;&#x3D;（Return Address）（或方法正常退出或者异常退出的定义）</li><li>&#x3D;&#x3D;一些附加信息&#x3D;&#x3D;</li></ul><p>&#x3D;&#x3D;影响栈帧大小的主要是局部变量表&#x3D;&#x3D;</p><h4 id="3、栈帧与线程"><a href="#3、栈帧与线程" class="headerlink" title="3、栈帧与线程"></a>3、栈帧与线程</h4><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051426796.png" alt="image-20210621112159119"></p><h2 id="三、局部变量表（Local-Variables）"><a href="#三、局部变量表（Local-Variables）" class="headerlink" title="三、局部变量表（Local Variables）"></a>三、局部变量表（Local Variables）</h2><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><ul><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型</li><li>由于局部变量表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>,并保存在方法的Code属性的【字节码最大长度】数据项中。在方法运行期间是不会改变局部变量表的大小的。</li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051426876.png" alt="image-20210621114340488"></p><ul><li><strong>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</strong><br>对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li><strong>局部变量表中的变量只在当前方法调用中有效。</strong>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></li></ul><h4 id="2、查看局部变量表"><a href="#2、查看局部变量表" class="headerlink" title="2、查看局部变量表"></a>2、查看局部变量表</h4><p>在IDEA 上安装jclasslib byte viewcoder插件查看局部变量表信息,以main()方法为例</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051427496.png" alt="image-20210621114111939"></p><h4 id="3、变量槽slot的理解与演示"><a href="#3、变量槽slot的理解与演示" class="headerlink" title="3、变量槽slot的理解与演示"></a>3、变量槽slot的理解与演示</h4><ul><li><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束</p></li><li><p>局部变量表，<strong>最基本的存储单元是Slot(变量槽)</strong></p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p></li><li><p>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong></p><ul><li>byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；</li><li>long和double则占据两个slot。</li></ul></li><li><p>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个slot上</strong></p><p><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用签一个索引即可。</strong>（比如：访问long或者double类型变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</p></li></ul><h4 id="4、slot的重复利用"><a href="#4、slot的重复利用" class="headerlink" title="4、slot的重复利用"></a>4、slot的重复利用</h4><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><h4 id="5、静态变量与局部变量的对比及小结"><a href="#5、静态变量与局部变量的对比及小结" class="headerlink" title="5、静态变量与局部变量的对比及小结"></a>5、静态变量与局部变量的对比及小结</h4><p>变量的分类：</p><ul><li>按照数据类型分：<ul><li>①基本数据类型;</li><li>②引用数据类型；</li></ul></li><li>按照在类中声明的位置分：<ul><li>①成员变量：在使用前，都经历过默认初始化赋值<ul><li>static修饰：类变量：类加载的链接的准备阶段给类变量默认赋值——&gt;初始化阶段给类变量显式赋值即静态代码块赋值；</li><li>不被static修饰：实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值</li></ul></li><li>②局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</li></ul></li><li>补充：<ul><li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul></li></ul><h2 id="四、操作数栈"><a href="#四、操作数栈" class="headerlink" title="四、操作数栈"></a>四、操作数栈</h2><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</strong></li><li>操作数栈就是jvm执行引擎的一个工作区，当一个方法开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的code属性中，为max_stack的值。</li><li>栈中的任何一个元素都是可以任意的java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈深度单位</li><li>操作数栈<strong>并非采用访问索引的方式来进行数据访问</strong>的，而是只能通过标砖的入栈push和出栈pop操作来完成一次数据访问</li></ul></li><li><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</strong>并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类验证阶段的数据流分析阶段要再次验证。</li></ul><h2 id="五、代码追踪"><a href="#五、代码追踪" class="headerlink" title="五、代码追踪"></a>五、代码追踪</h2><p>Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>,其中的栈指的就是操作数栈。<br><strong>结合操作数栈的概念来看一下一个方法（栈帧）的执行过程</strong></p><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">        <span class="type">byte</span> i=<span class="number">15</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> k=i+j;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>查看其字节码文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> bipush <span class="number">15</span> <span class="comment">//将值转化为int 保存到操作数栈中</span></span><br><span class="line">        <span class="number">2</span> istore_1 <span class="comment">//将int的值15保存到局部变量表中</span></span><br><span class="line">        <span class="number">3</span> bipush <span class="number">8</span> <span class="comment">//将值8存入到操作数栈中</span></span><br><span class="line">        <span class="number">5</span> istore_2 <span class="comment">//将8存入局部变量表中</span></span><br><span class="line">        <span class="number">6</span> iload_1 <span class="comment">// 从局部变量表中取出索引为1的值 15 放入操作数栈中</span></span><br><span class="line">        <span class="number">7</span> iload_2 <span class="comment">// 从局部变量表中取出索引为2的值 8 放入操作数栈中</span></span><br><span class="line">        <span class="number">8</span> iadd <span class="comment">// 将操作数栈中出栈两个值 相加</span></span><br><span class="line">        <span class="number">9</span> istore_3 <span class="comment">// 将上一步的结果放入局部变量表索引3的位置</span></span><br><span class="line">        10return <span class="comment">//成功返回</span></span><br></pre></td></tr></table></figure><h2 id="六、栈顶缓存技术"><a href="#六、栈顶缓存技术" class="headerlink" title="六、栈顶缓存技术"></a>六、栈顶缓存技术</h2><ul><li><p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数</p></li><li><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，**<br>将栈顶元素全部缓存在CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率**</p></li></ul><h2 id="七、动态链接"><a href="#七、动态链接" class="headerlink" title="七、动态链接"></a>七、动态链接</h2><ul><li><p>每一个栈帧内部都包含一个指向运行时常量池或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</p></li><li><p>在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic<br>Refenrence）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></p></li></ul><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051427945.png" alt="image-20210621211858286"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLinkingTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//methodA方法的类文件</span></span><br><span class="line"><span class="number">0</span> getstatic #<span class="number">3</span>&lt;java/lang/System.out&gt; <span class="comment">// 符号引用 从常量池中读取</span></span><br><span class="line">        <span class="number">3</span> ldc #<span class="number">4</span>&lt;methodA()....&gt;</span><br><span class="line">        <span class="number">5</span> invokevirtual #<span class="number">5</span>&lt;java/io/PrintStream.println&gt;</span><br><span class="line">        8return</span><br></pre></td></tr></table></figure><h2 id="八、方法的调用：解析与分派"><a href="#八、方法的调用：解析与分派" class="headerlink" title="八、方法的调用：解析与分派"></a>八、方法的调用：解析与分派</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><p><strong>静态链接</strong><br>当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p></li><li><p><strong>动态链接</strong><br>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p></li></ul><p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h2 id="九、方法返回地址"><a href="#九、方法返回地址" class="headerlink" title="九、方法返回地址"></a>九、方法返回地址</h2><ul><li>存放调用该方法的PC寄存器的值。</li><li>一个方法的结束，有两种方式：<ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong><br>而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li><li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值也如调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li><li><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></li></ul><p>当一个方法开始执行后，只要两种方式可以退出这个方法： 1、执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li><li></li></ul><p>在字节码指令中，返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</p><p>2、在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜素到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong><br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p><h2 id="十、附加信息"><a href="#十、附加信息" class="headerlink" title="十、附加信息"></a>十、附加信息</h2><p>栈帧中还允许携带与java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。（很多资料都忽略了附加信息）</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-类加载器的常用方法</title>
      <link href="/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载的常用方法"><a href="#类加载的常用方法" class="headerlink" title="类加载的常用方法"></a>类加载的常用方法</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）"><a href="#ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）" class="headerlink" title="ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）"></a>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</h4><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent（）</td><td>返回该类加载器的超类加载器</td></tr><tr><td>loadClass（String name）</td><td>加载名称为name的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>findClass（String name）</td><td>查找名称为name的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>findLoadedClass（String name）</td><td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>defineClass（String name，byte[] b,int off,int len）</td><td>把字节数组b中的内容转换为一个Java类 ，返回结果为java.lang.Class类的实例</td></tr><tr><td>resolveClass（Class&lt;?&gt; c）</td><td>连接指定的一个java类</td></tr></tbody></table><h2 id="ClassLoader继承关系"><a href="#ClassLoader继承关系" class="headerlink" title="ClassLoader继承关系"></a>ClassLoader继承关系</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051415566.png" alt="image-20210617214555582"></p><h2 id="获取ClassLoader的途径"><a href="#获取ClassLoader的途径" class="headerlink" title="获取ClassLoader的途径"></a>获取ClassLoader的途径</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051415647.png" alt="image-20210617214611472"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-双亲委派机制</title>
      <link href="/JVM-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
      <url>/JVM-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​ Java虚拟机对class文件采用的是按需加载的方式，</p><p>​ 也就是说当需要使用该类时才会将它的class文件加载到内存生成的class对象。</p><p>​ 而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式。</p><p>​ 即把请求交由父类处理，它是一种任务委派模式</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051416768.png" alt="image-20210617212921462"></p><ol><li><h5 id="如果一个类加载器收到了类加载的请求，它并不会自己加载，而是先把请求委托给父类的加载器执行"><a href="#如果一个类加载器收到了类加载的请求，它并不会自己加载，而是先把请求委托给父类的加载器执行" class="headerlink" title="如果一个类加载器收到了类加载的请求，它并不会自己加载，而是先把请求委托给父类的加载器执行"></a>如果一个类加载器收到了类加载的请求，它并不会自己加载，而是先把请求委托给父类的加载器执行</h5></li><li><h5 id="如果父类加载器还有父类，则进一步向上委托，依次递归，请求到达最顶层的引导类加载器。"><a href="#如果父类加载器还有父类，则进一步向上委托，依次递归，请求到达最顶层的引导类加载器。" class="headerlink" title="如果父类加载器还有父类，则进一步向上委托，依次递归，请求到达最顶层的引导类加载器。"></a>如果父类加载器还有父类，则进一步向上委托，依次递归，请求到达最顶层的引导类加载器。</h5></li><li><h5 id="如果顶层类的加载器加载成功，则成功返回。如果失败，则子加载器会尝试加载。直到加载成功。"><a href="#如果顶层类的加载器加载成功，则成功返回。如果失败，则子加载器会尝试加载。直到加载成功。" class="headerlink" title="如果顶层类的加载器加载成功，则成功返回。如果失败，则子加载器会尝试加载。直到加载成功。"></a>如果顶层类的加载器加载成功，则成功返回。如果失败，则子加载器会尝试加载。直到加载成功。</h5></li></ol><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>通过查看最顶层父类ClassLoader的loaderClass方法，我们可以验证双亲委派机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name,<span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name))&#123;</span><br><span class="line">        <span class="comment">// 首先检查此类是否被加载过了 </span></span><br><span class="line">        Class&lt;?&gt; c=findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">long</span> t0=System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的加载器方法</span></span><br><span class="line">        <span class="keyword">if</span>(parent!=<span class="literal">null</span>)&#123;</span><br><span class="line">        c=parent.loadClass(name,<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 此时是最顶级的启动类加载器</span></span><br><span class="line">        c=findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">        <span class="comment">// 抛出异常说明父类无法加载</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//父类无法加载的时候，由子类进行加载。</span></span><br><span class="line">        <span class="comment">// to find the class.</span></span><br><span class="line">        <span class="type">long</span> t1=System.nanoTime();</span><br><span class="line">        c=findClass(name);</span><br><span class="line">        <span class="comment">//记录加载时间已经加载耗时</span></span><br><span class="line">        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1-t0);</span><br><span class="line">        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">        sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(resolve)&#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h2><ul><li><p>避免类的重复加载</p><p>当自己程序中定义了一个和Java.lang包同名的类，此时，由于使用的是双亲委派机制，会由启动类加载器去加载<code>JAVA_HOME/lib</code>中的类，而不是加载用户自定义的类。此时，程序可以正常编译，但是自己定义的类无法被加载运行。</p></li><li><p>保护程序安全，防止核心API被随意篡改</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-类加载过程</title>
      <link href="/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051415812.png" alt="image-20210730191532573"></p><p>类加载的过程主要分为三个阶段 加载，链接，初始化。 而链接阶段又可以细分为验证，准备，解析三个子阶段。</p><p>接下来，我们详细分析下类加载的过程。</p><h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><p>加载过程需要完成以下三个事情:</p><ul><li><p>通过一个类的<code>全限定名</code>获取定义此类的<code>二进制字节流</code>；</p></li><li><p>将这个字节流所代表的的<code>静态存储结构</code>转化为方法区的<code>运行时数据结构</code>；</p></li><li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种<code>数据的访问入口 </code></p></li></ul><p>《Java虚拟机规范 》对这三点的要求并不是特别的具体。因此，留给虚拟机实现于Java的应用的灵活度都是很大的。</p><p>在第一步<code>通过一个类的全限定名</code>获取字节流的时候，并没有规范一定是从字节码文件获取，更没有规定是从本地文件中获取。因此，虚拟机的实现者就可以在加载阶段就构建出一个相当开放的舞台。</p><ul><li><p>从ZIP压缩文件中读取，最终成为日后JAR包，WAR包的基础</p></li><li><p>从网络中获取，这种情况最典型的就是Web Applet。</p></li><li><p>运行时生成，从而为后来的动态代理技术奠定了理论基础。</p></li><li><p>从其他文件中生成，典型的应用就是Web中的JSP技术。由JSP文件编译生成字节码文件。</p></li><li><p>从数据库获取，例如中间件服务器，可以选择把程序安装到数据库中完成程序代码在集群中的分发。</p><p>……</p></li></ul><p>加载结束之后，外部的二进制字节流就会以JVM所设定的格式存在于方法区中了。<br>之后会在堆中实例一个java.lang.class类型的对象，<br>这个对象作为程序访问方法区中的类型数据的入口。</p><h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051415807.png" alt="加载示例"></p><ol><li><h3 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify)"></a>验证(Verify)</h3><h5 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的:"></a>1. 目的:</h5><p>在于确保Class文件的字节流中包含信息符合当前JVM规范要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><h5 id="2-主要包括四种验证"><a href="#2-主要包括四种验证" class="headerlink" title="2. 主要包括四种验证"></a>2. 主要包括四种验证</h5><ul><li><p><code>文件格式验证</code></p><ul><li>字节码是否以十六进制的<code>CAFEBABE</code>开头</li><li>主，次版本号是否在当前虚拟机可接受的范围之内。</li><li>常量池的常量中是否有不被支持的类型</li><li>Class文件中是否有被添加的其他恶意信息。</li></ul><p>文件格式验证不止以上，上面所列举的只是从HotSpot虚拟机源码中摘抄的一部分。只有通过这个阶段的验证之后，这一段字节流才会进入虚拟机内存中进行存储，<br>之后的过程都是基于方法区中的存储结构进行的。不会直接读取字节流了。</p></li><li><p><code>源数据验证</code></p><p>用于保证字节码中的代码符合《Java语言规范》</p><ul><li>此类的父类是否是不可继承的类（Final修饰的）</li><li>如果此类不是抽象类，它是否实现了全部需要实现的方法。</li><li>类中的字段，方法是否和父类冲突。</li><li>……</li></ul></li><li><p><code>字节码验证</code></p><p>此过程保证代码是符合逻辑的，对代码的流程进行判断，保证不会出现危害虚拟机安全的情况。</p><ul><li>保证任意时刻操作数栈中的类型和指令代码序列可以正常工作，比如执行到iadd字节码指令，但是操作数栈顶有一位是Long类型的。</li><li>保证代码中的类型转换是有效的。</li></ul><p>如果一个类型中的方法体没有通过次阶段，那它一定是有问题的。但是，不可以认为只要通过此阶段验证，一定没有问题。通过程序去校验程序的逻辑是无法做到绝对准确的。</p></li><li><p><code>符号引用验证</code>。</p><p>此阶段验证符号引用是否合法，主要用于解析阶段的前置任务。</p><p>主要用于判断 该类中是否存在缺少后者被禁止访问它依赖的某些外部类，字段，方法等资源。</p></li></ul></li><li><h3 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a>准备(Prepare)</h3><ul><li><p>为类变量（static）分配内存并且设置初始值。</p></li><li><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p></li><li><p>不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到java堆中。</p></li></ul></li><li><h3 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h3><ul><li><p>将常量池内的符号引用转换为直接引用的过程。</p></li><li><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</p></li><li><p>符号引用就是一组符号来描述所引用的目标。符号应用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<code>CONSTANT_Class_info</code>&#x2F;<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>等。</p></li></ul></li></ol><h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><ul><li><p>初始化阶段就是执行类构造器方法clInit()的过程。 clInit是ClassInit缩写。此方法并不是程序员定义的构造方法。</p></li><li><p>是javac编译器自动收集类中的所有类变量(Static)的赋值动作和静态代码块中的语句合并而来。</p></li><li><p>构造器方法中指令按语句在源文件中出现的顺序执行</p></li><li><p>若该类具有父类，jvm会保证子类的clinit()执行前，父类的clinit()已经执行完毕</p><p>比如如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @作者: 写Bug的小杜 【email@shaoxiongdu.cn】</span></span><br><span class="line"><span class="comment"> * @时间: 2021/07/30</span></span><br><span class="line"><span class="comment"> * @描述:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CInitTestMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(B.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行，发现B类中b的值为20 由于是父类的CInit方法先执行，也就是说父类的静态代码块中的内容优于子类的赋值操作先执行。</p></li><li><p>虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。</p><p>验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @作者: 写Bug的小杜 【email@shaoxiongdu.cn】</span></span><br><span class="line"><span class="comment"> * @时间: 2021/07/30</span></span><br><span class="line"><span class="comment"> * @描述: 测试一个类的CInit方法是否被加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 如果不加这个判断 编译器会报死循环的错误</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程正在执行CInit方法&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLoopClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">                <span class="type">TestClass</span> <span class="variable">testClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClass</span>(); <span class="comment">//触发加载TestClass类</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下： 当一条线程死循环在CInit处，别的线程也会阻塞。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051415564.png" alt="image-20210730195642762"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-类加载器的分类</title>
      <link href="/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/"/>
      <url>/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有三个，如下所示：</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051415727.png" alt="image-20210730200638388"></p><ul><li><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><ul><li>负责加载<code>JAVA_HOME/lib</code>目录下的可以被虚拟机识别（通过文件名称，比如<code>rt.jar``tools.jar</code>）的字节码文件。</li><li>与之对应的是<code>java.lang.ClassLoader</code>类</li></ul></li><li><h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><ul><li>负责加载<code>JAVA_HOME/lib/ext</code>目录下的的字节码文件。</li><li>对应<code>sun.misc.Launcher</code>类 此类继承于启动类加载器<code>ClassLoader</code></li></ul></li><li><h3 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h3><ul><li>负责加载<code>ClassPath</code>路径下的字节码 也就是用户自己写的类。</li><li>对应于<code>sun.misc.Launcher.AppClassLoader</code>类 此类继承于扩展类加载器<code>Launcher</code></li></ul></li><li><h3 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h3><ul><li><p>需要继承系统类加载器<code>ClassLoader</code>，并重写<code>findClass</code>方法。</p></li><li><p>负责加载指定位置的字节码文件。通过类中的path变量指定。</p></li><li><p>如下为用户重写的自定义加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.shaoxiongdu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @作者: 写Bug的小杜 【email@shaoxiongdu.cn】</span></span><br><span class="line"><span class="comment"> * @时间: 2021/07/30</span></span><br><span class="line"><span class="comment"> * @描述: 用户自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String path=<span class="string">&quot;/home/lib/&quot;</span>;    <span class="comment">//默认加载路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;                    <span class="comment">//类加载器名称</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String  filetype=<span class="string">&quot;.class&quot;</span>; <span class="comment">//文件类型</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">byte</span>[] b=loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        <span class="type">byte</span>[] data=<span class="literal">null</span>;</span><br><span class="line">        InputStream in=<span class="literal">null</span>;</span><br><span class="line">        name=name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        ByteArrayOutputStream out=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(path+name+filetype));</span><br><span class="line">            <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(-<span class="number">1</span>!=(len=in.read()))&#123;</span><br><span class="line">                out.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">            data=out.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载子系统</title>
      <link href="/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051414804.jpg" alt="JVM底层体系"></p><blockquote><p>代码编译的结果从本地机器指令码转化为字节码，是存储格式发展的一小步，但却是编程语言发展的一大步</p><p>​ —— 《深入理解JVM虚拟机》周志明·著</p></blockquote><p>​ Java虚拟机将描述类的数据从class字节码文件加载到内存，并且对数据进行校验，转化，解析，初始化的工作，最终形成在内存中可以直接使用的数据类型。<br>这个过程叫做虚拟机的类加载机制。</p><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051415584.png" alt="类加载子系统"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><h5 id="类加载子系统负责从文件系统或者网络中加载Class文件（Class文件在开头有特定标识）。"><a href="#类加载子系统负责从文件系统或者网络中加载Class文件（Class文件在开头有特定标识）。" class="headerlink" title="类加载子系统负责从文件系统或者网络中加载Class文件（Class文件在开头有特定标识）。"></a>类加载子系统负责从文件系统或者网络中加载Class文件（Class文件在开头有特定标识）。</h5></li><li><h5 id="l类加载器-Class-Loader-只负责class文件的加载，至于是否可以运行，由执行引擎（Execution-Engine）决定。"><a href="#l类加载器-Class-Loader-只负责class文件的加载，至于是否可以运行，由执行引擎（Execution-Engine）决定。" class="headerlink" title="l类加载器(Class Loader)只负责class文件的加载，至于是否可以运行，由执行引擎（Execution Engine）决定。"></a>l类加载器(Class Loader)只负责class文件的加载，至于是否可以运行，由执行引擎（Execution Engine）决定。</h5></li><li><h5 id="加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）"><a href="#加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）" class="headerlink" title="加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）"></a>加载的类信息存放于一块成为方法区的内存空间。除了类信息之外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</h5></li></ul><h2 id="类加载器扮演的角色"><a href="#类加载器扮演的角色" class="headerlink" title="类加载器扮演的角色"></a>类加载器扮演的角色</h2><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/MacBookPro202208051414783.png" alt="image-20210617111632499"></p><ul><li><p>Car.class存放于本地硬盘中，在运行的时候，JVM将Car.class文件加载到JVM中，被称为DNA元数据模板</p><p>存放在JVM的方法区中，之后根据元数据模板实例化出相应的对象。</p></li><li><p>在 <code>.class</code> -&gt; <code>JVM</code> -&gt; <code>元数据模板</code> -&gt; <code>实例对象</code> 这个过程中，类加载器扮演者快递员的角色。</p></li></ul><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>关于类加载的时机，《Java虚拟机规范》中并没有明确规定。这点可以由虚拟机的具体实现决定。</p><p>但是类的初始化阶段，规范中明确规定当某个类没有进行初始化，<strong>只有以下6中情况才会触发其初始化过程。</strong></p><ol><li>遇到<code>new</code>,<code>getStatic</code>，<code>putStatic</code>,<code>invokeStatic</code>,这四条字节码指令的时候，如果改类型没有进行初始化，则会触发其初始化。也就是如下情况<br>1.1. 遇到<code>new</code>关键字进行创建对象的时候。<br>1.2. 读取或者设置一个类的静态字段的时候（必须被final修饰，也就是在编译器把结果放入常量池中)。<br>1.3. 调用一个类的静态方法的时候。</li><li>使用java.lang.reflect进行反射调用的时候。</li><li>当初始化某个类，发现其父类没有初始化的时候。</li><li>当虚拟机启动的时候，会触发其主方法所在的类进行初始化。</li><li>当使用JDK1.7中的动态语言支持时，如果一个<code>java.lang.invoke.MethidHandle</code>实例最后的解析结果为<code>REF_getStatic</code>,<code>REF_putStatic</code>,<code>REF_invokeStatic</code><br>,<code>REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个句柄对应的类没有被初始化。</li><li>当一个接口实现了JDK1.8中的默认方法的时候，如果这个接口的实现类被初始化，则该接口要在其之前进行实例化。</li></ol><p>对于以上6中触发类的初始化条件，在JVM规范中有一个很强制的词，<code>if and only if</code> （有且只有）。这六种行为被称为对<code>类进行主动引用</code>，除此之外，其他引用类的方式均不会触发类的初始化。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的一天</title>
      <link href="/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
      <url>/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>早上八点醒来，又是阴天，云朵好懒啊，不涂防晒，变成乌云，最后委屈的哭了出来。</p><p>冒着雨来到公司，终于准点打卡，记得初恋总是埋怨我约会迟到，可能被偏爱的人才会有恃无恐，后来我终于学会了准时，却永远错过了17岁时年少的喜欢。</p><p>看着评审会的同事们，我非常好奇，他们的满目山河在哪里，他们的可望而不可得又在哪里，可是又是怎样的缘分，让我们一起参加了这样的会。</p><p>会上产品说需求不会再变了时，我想起来十八岁那年平安夜，那一晚雪很大，路灯很暖，你笑着对我说：我们要永远在一起。你曾经填满我的过去，却在我们约定好的未来永久缺席。</p><p>不过我越来越能接受需求频繁改变的事实，承诺会变，爱情会变，纵然相思入骨最后也会天涯陌路，我们又怎么能奢求需求不会变呢？</p><p>散会了，产品和我说排期紧，这段时间比较难熬，坚持一下，我笑了，最难熬的不是漫漫长夜，不是两月三年，也不是两人相爱的不能见面，而是我爱的人不爱我。</p><p>下午做技术分享，结束之后别人一直夸我技术掌握多么多么好，但我仍然记得，第一次看见屏幕上出现hello world 的欣喜之情，那份欣喜，现在没有了，以后也不会有了。</p><p>分享的时候，有人提问：”你是在学会开发项目的那个晚上变成大神的吗”？我思考片刻：”不是，是我没学会但是决定再学一遍的时候。”</p><p>傍晚时候，我终于有时间开始编程，黄昏的时候写上几行代码，载着落日的余晖和银河的浪漫，当成功运行的那一刻，我看见是编译器对我的温柔。</p><p>没写多久，收到测试给我提的Bug，其实测试提Bug的时候我很开心，因为我已经学会了一个人送走落日，一个人等待星光，一个人桀骜不驯和年少轻狂，突然有人关心我说：”有问题，不着急，慢慢改”，这是一生之中，我最为安慰的事情。</p><p>记得最初写代码，有一个Warning报警我都要熬夜排查出来，后来时间稍微久了一点，就算是Error报警，我连日志都懒得看了。大抵对事对物都如此，起初她皱一下眉头你都会心疼，后来她哭你也无所谓了。</p><p>解决问题后，用着熟悉的git命令推送部署。对了，执行git命令如果没有返回任何消息，就代表着执行成功。就好像她的不回复，其实也是一种回复。</p><p>忙完了，和同事一起吃饭，听着他们的吐槽，不禁感觉世人多奇怪，996嫌累，摸鱼觉得没意思，使用开源库觉得没技术含量，自己造轮子又不会。写代码羡慕领导写PPT，写PPT害怕自己没有硬实力。终其一生，满是遗憾。</p><p>是的，世上哪那么多成全，从小到大听过最多的成全就是:”不想干了是吧，我成全你”。</p><p>深夜无心睡眠，不由自主想是不是在另一个平行时空，有一个跟我长得很像很像的人，可以把编程只是当做爱好，把写作只是当做分享，灿烂的活着，热烈的爱着，不用像我一样，在无数个孤立无援的时刻里把自己消耗殆尽，拼尽全力，只为成为一个普通人。</p><p><img src="https://images-1301128659.cos.ap-beijing.myqcloud.com/IMG_20220325_222803.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
